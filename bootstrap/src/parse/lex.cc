/* Generated by re2c 2.1.1 on Wed Jul 14 07:38:47 2021 */
#line 1 "../src/parse/lex.re"
#include <ctype.h>
#include "src/util/c99_stdint.h"
#include <limits>
#include <string>
#include <utility>
#include <vector>

#include "src/codegen/code.h"
#include "src/encoding/enc.h"
#include "src/msg/location.h"
#include "src/msg/msg.h"
#include "src/msg/warn.h"
#include "src/options/opt.h"
#include "src/parse/ast.h"
#include "src/parse/input.h"
#include "src/parse/lex.h"
#include "src/parse/scanner.h"
#include "src/parse/parse.h" // needed by "parser.h"
#include "src/parse/unescape.h"
#include "src/regexp/rule.h"
#include "src/util/file_utils.h"
#include "src/util/s_to_n32_unsafe.h"
#include "src/util/string_utils.h"
#include "parser.h"


extern YYSTYPE yylval;

namespace re2c {

#define YYCTYPE   unsigned char
#define YYCURSOR  cur
#define YYLIMIT   lim
#define YYMARKER  mar
#define YYFILL(n) do { if (!fill(n)) { error("unexpected end of input"); exit(1); }} while(0)

#line 62 "../src/parse/lex.re"


#line 121 "../src/parse/lex.re"


InputBlockKind Scanner::echo(Output &out, std::string &block_name)
{
    const opt_t *opts = out.block().opts;
    code_alc_t &alc = out.allocator;
    const char *x, *y;
    BlockNameList *block_list;

    if (is_eof()) return INPUT_END;

next:
    tok = cur;
loop:
    location = cur_loc();
    ptr = cur;

#line 61 "src/parse/lex.cc"
{
	YYCTYPE yych;
	unsigned int yyaccept = 0;
	static const unsigned char yybm[] = {
		  0, 128, 128, 128, 128, 128, 128, 128, 
		128, 160,   0, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		160, 128,   0, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128,   0, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
	};
	if ((YYLIMIT - YYCURSOR) < 18) YYFILL(18);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= '\r') {
		if (yych <= '\t') {
			if (yych >= 0x01) goto yy4;
		} else {
			if (yych <= '\n') goto yy6;
			if (yych <= '\f') goto yy4;
			goto yy8;
		}
	} else {
		if (yych <= '%') {
			if (yych <= '$') goto yy4;
			goto yy9;
		} else {
			if (yych == '/') goto yy10;
			goto yy4;
		}
	}
	++YYCURSOR;
#line 269 "../src/parse/lex.re"
	{
        if (is_eof()) {
            out.wraw(tok, ptr);
            return INPUT_END;
        }
        goto loop;
    }
#line 127 "src/parse/lex.cc"
yy4:
	++YYCURSOR;
yy5:
#line 289 "../src/parse/lex.re"
	{ goto loop; }
#line 133 "src/parse/lex.cc"
yy6:
	yyaccept = 0;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 32) {
		goto yy11;
	}
	if (yych == '#') goto yy14;
yy7:
#line 284 "../src/parse/lex.re"
	{
        next_line();
        goto loop;
    }
#line 147 "src/parse/lex.cc"
yy8:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy6;
	goto yy5;
yy9:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '{') goto yy16;
	goto yy5;
yy10:
	yyaccept = 1;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych == '*') goto yy18;
	goto yy5;
yy11:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 32) {
		goto yy11;
	}
	if (yych == '#') goto yy14;
yy13:
	YYCURSOR = YYMARKER;
	if (yyaccept <= 2) {
		if (yyaccept <= 1) {
			if (yyaccept == 0) {
				goto yy7;
			} else {
				goto yy5;
			}
		} else {
			goto yy161;
		}
	} else {
		if (yyaccept == 3) {
			goto yy163;
		} else {
			goto yy172;
		}
	}
yy14:
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 5) YYFILL(5);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy14;
		goto yy13;
	} else {
		if (yych <= ' ') goto yy14;
		if (yych == 'l') goto yy19;
		goto yy13;
	}
yy16:
	++YYCURSOR;
#line 138 "../src/parse/lex.re"
	{
        out.wraw(tok, ptr);
        block_name.clear();
        return INPUT_GLOBAL;
    }
#line 208 "src/parse/lex.cc"
yy18:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '!') goto yy20;
	goto yy13;
yy19:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'i') goto yy21;
	goto yy13;
yy20:
	yych = (YYCTYPE)*++YYCURSOR;
	switch (yych) {
	case 'g':	goto yy22;
	case 'h':	goto yy23;
	case 'i':	goto yy24;
	case 'l':	goto yy25;
	case 'm':	goto yy26;
	case 'r':	goto yy27;
	case 's':	goto yy28;
	case 't':	goto yy29;
	case 'u':	goto yy30;
	default:	goto yy13;
	}
yy21:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'n') goto yy31;
	goto yy13;
yy22:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy32;
	goto yy13;
yy23:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy33;
	goto yy13;
yy24:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'g') goto yy34;
	if (yych == 'n') goto yy35;
	goto yy13;
yy25:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'o') goto yy36;
	goto yy13;
yy26:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'a') goto yy37;
	if (yych == 't') goto yy38;
	goto yy13;
yy27:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy39;
	if (yych == 'u') goto yy40;
	goto yy13;
yy28:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 't') goto yy41;
	goto yy13;
yy29:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'y') goto yy42;
	goto yy13;
yy30:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 's') goto yy43;
	goto yy13;
yy31:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy44;
	goto yy13;
yy32:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 't') goto yy45;
	goto yy13;
yy33:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'a') goto yy46;
	goto yy13;
yy34:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'n') goto yy47;
	goto yy13;
yy35:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'c') goto yy48;
	goto yy13;
yy36:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'c') goto yy49;
	goto yy13;
yy37:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'x') goto yy50;
	goto yy13;
yy38:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'a') goto yy51;
	goto yy13;
yy39:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '2') goto yy52;
	goto yy13;
yy40:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'l') goto yy53;
	goto yy13;
yy41:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'a') goto yy54;
	goto yy13;
yy42:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'p') goto yy55;
	goto yy13;
yy43:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy56;
	goto yy13;
yy44:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '0') goto yy58;
	if (yych <= '9') goto yy13;
	goto yy58;
yy45:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 's') goto yy59;
	goto yy13;
yy46:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'd') goto yy60;
	goto yy13;
yy47:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'o') goto yy61;
	goto yy13;
yy48:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'l') goto yy62;
	goto yy13;
yy49:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'a') goto yy63;
	goto yy13;
yy50:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == ':') goto yy64;
	if (yych == 'n') goto yy65;
	goto yy13;
yy51:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'g') goto yy66;
	goto yy13;
yy52:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'c') goto yy67;
	goto yy13;
yy53:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy69;
	goto yy13;
yy54:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'g') goto yy70;
	goto yy13;
yy55:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy71;
	goto yy13;
yy56:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == ':') goto yy72;
	goto yy13;
yy57:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
yy58:
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy57;
		goto yy13;
	} else {
		if (yych <= ' ') goto yy57;
		if (yych <= '0') goto yy13;
		if (yych <= '9') {
			yyt1 = YYCURSOR;
			goto yy73;
		}
		goto yy13;
	}
yy59:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 't') goto yy75;
	goto yy13;
yy60:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy76;
	goto yy13;
yy61:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'r') goto yy77;
	goto yy13;
yy62:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'u') goto yy78;
	goto yy13;
yy63:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'l') goto yy79;
	goto yy13;
yy64:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'r') goto yy80;
	goto yy13;
yy65:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'm') goto yy81;
	goto yy13;
yy66:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 's') goto yy82;
	goto yy13;
yy67:
	++YYCURSOR;
#line 144 "../src/parse/lex.re"
	{
        out.wraw(tok, ptr);
        if (!lex_opt_name(block_name)) return INPUT_ERROR;
        return INPUT_GLOBAL;
    }
#line 437 "src/parse/lex.cc"
yy69:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 's') goto yy83;
	goto yy13;
yy70:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 's') goto yy84;
	goto yy13;
yy71:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 's') goto yy85;
	goto yy13;
yy72:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'r') goto yy86;
	goto yy13;
yy73:
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 64) {
		goto yy73;
	}
	if (yych <= '\f') {
		if (yych <= 0x08) goto yy13;
		if (yych <= '\t') goto yy87;
		if (yych <= '\n') goto yy89;
		goto yy13;
	} else {
		if (yych <= '\r') goto yy91;
		if (yych == ' ') goto yy87;
		goto yy13;
	}
yy75:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'a') goto yy92;
	goto yy13;
yy76:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'r') goto yy93;
	goto yy13;
yy77:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy94;
	goto yy13;
yy78:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'd') goto yy95;
	goto yy13;
yy79:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == ':') goto yy96;
	goto yy13;
yy80:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy97;
	goto yy13;
yy81:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'a') goto yy98;
	goto yy13;
yy82:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == ':') goto yy99;
	goto yy13;
yy83:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == ':') goto yy100;
	goto yy13;
yy84:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == ':') goto yy101;
	goto yy13;
yy85:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == ':') goto yy102;
	goto yy13;
yy86:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy103;
	goto yy13;
yy87:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy87;
		goto yy13;
	} else {
		if (yych <= ' ') goto yy87;
		if (yych == '"') goto yy104;
		goto yy13;
	}
yy89:
	++YYCURSOR;
	YYCURSOR = yyt1;
#line 277 "../src/parse/lex.re"
	{
        out.wraw(tok, ptr);
        out.wdelay_stmt(0, code_newline(alc));
        set_sourceline();
        goto next;
    }
#line 541 "src/parse/lex.cc"
yy91:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy89;
	goto yy13;
yy92:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 't') goto yy106;
	goto yy13;
yy93:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == ':') goto yy107;
	goto yy13;
yy94:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == ':') goto yy108;
	goto yy13;
yy95:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy109;
	goto yy13;
yy96:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'r') goto yy110;
	goto yy13;
yy97:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '2') goto yy111;
	goto yy13;
yy98:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 't') goto yy112;
	goto yy13;
yy99:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'r') goto yy113;
	goto yy13;
yy100:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'r') goto yy114;
	goto yy13;
yy101:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'r') goto yy115;
	goto yy13;
yy102:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'r') goto yy116;
	goto yy13;
yy103:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '2') goto yy117;
	goto yy13;
yy104:
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy104;
	}
	if (yych <= '\n') goto yy13;
	if (yych <= '"') goto yy118;
	goto yy119;
yy106:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy120;
	goto yy13;
yy107:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'r') goto yy121;
	goto yy13;
yy108:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'r') goto yy122;
	goto yy13;
yy109:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == ':') goto yy123;
	goto yy13;
yy110:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy124;
	goto yy13;
yy111:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'c') goto yy125;
	goto yy13;
yy112:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'c') goto yy127;
	goto yy13;
yy113:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy128;
	goto yy13;
yy114:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy129;
	goto yy13;
yy115:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy130;
	goto yy13;
yy116:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy131;
	goto yy13;
yy117:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'c') goto yy132;
	goto yy13;
yy118:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy89;
	if (yych == '\r') goto yy91;
	goto yy13;
yy119:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= 0x00) goto yy13;
	if (yych == '\n') goto yy13;
	goto yy104;
yy120:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == ':') goto yy134;
	goto yy13;
yy121:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy135;
	goto yy13;
yy122:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy136;
	goto yy13;
yy123:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'r') goto yy137;
	goto yy13;
yy124:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '2') goto yy138;
	goto yy13;
yy125:
	++YYCURSOR;
#line 168 "../src/parse/lex.re"
	{
        out.wraw(tok, ptr);
        if (!lex_name_list(alc, &block_list)) return INPUT_ERROR;
        if (!lex_max(out, MAX_FILL, block_list)) return INPUT_ERROR;
        goto next;
    }
#line 693 "src/parse/lex.cc"
yy127:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'h') goto yy139;
	goto yy13;
yy128:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '2') goto yy140;
	goto yy13;
yy129:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '2') goto yy141;
	goto yy13;
yy130:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '2') goto yy142;
	goto yy13;
yy131:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '2') goto yy143;
	goto yy13;
yy132:
	++YYCURSOR;
#line 162 "../src/parse/lex.re"
	{
        out.wraw(tok, ptr);
        if (!lex_opt_name(block_name)) return INPUT_ERROR;
        return INPUT_USE;
    }
#line 722 "src/parse/lex.cc"
yy134:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'r') goto yy144;
	goto yy13;
yy135:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '2') goto yy145;
	goto yy13;
yy136:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '2') goto yy146;
	goto yy13;
yy137:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy147;
	goto yy13;
yy138:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'c') goto yy148;
	goto yy13;
yy139:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == ':') goto yy150;
	goto yy13;
yy140:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'c') goto yy151;
	goto yy13;
yy141:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'c') goto yy153;
	goto yy13;
yy142:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'c') goto yy155;
	goto yy13;
yy143:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'c') goto yy157;
	goto yy13;
yy144:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy159;
	goto yy13;
yy145:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'c') goto yy160;
	goto yy13;
yy146:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'c') goto yy162;
	goto yy13;
yy147:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '2') goto yy164;
	goto yy13;
yy148:
	++YYCURSOR;
#line 150 "../src/parse/lex.re"
	{
        out.wraw(tok, ptr);
        if (!lex_opt_name(block_name)) return INPUT_ERROR;
        return INPUT_LOCAL;
    }
#line 787 "src/parse/lex.cc"
yy150:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'r') goto yy165;
	goto yy13;
yy151:
	++YYCURSOR;
#line 216 "../src/parse/lex.re"
	{
        out.wraw(tok, ptr);
        if (!lex_name_list(alc, &block_list)) return INPUT_ERROR;
        if (!lex_tags(out, block_list, true)) return INPUT_ERROR;
        goto next;
    }
#line 801 "src/parse/lex.cc"
yy153:
	++YYCURSOR;
#line 156 "../src/parse/lex.re"
	{
        out.wraw(tok, ptr);
        if (!lex_opt_name(block_name)) return INPUT_ERROR;
        return INPUT_RULES;
    }
#line 810 "src/parse/lex.cc"
yy155:
	++YYCURSOR;
#line 209 "../src/parse/lex.re"
	{
        out.wraw(tok, ptr);
        if (!lex_name_list(alc, &block_list)) return INPUT_ERROR;
        if (!lex_tags(out, block_list, false)) return INPUT_ERROR;
        goto next;
    }
#line 820 "src/parse/lex.cc"
yy157:
	++YYCURSOR;
#line 197 "../src/parse/lex.re"
	{
        out.wraw(tok, ptr);
        out.wdelay_stmt(0, code_line_info_output(alc));
        if (!lex_name_list(alc, &block_list)) return INPUT_ERROR;
        if (!lex_end_of_block(out)) return INPUT_ERROR;
        out.wdelay_stmt(opts->topIndent, code_cond_enum(alc, block_list));
        out.cond_enum_in_hdr = out.in_header();
        out.warn_condition_order = false; // see note [condition order]
        out.wdelay_stmt(0, code_line_info_input(alc, cur_loc()));
        goto next;
    }
#line 835 "src/parse/lex.cc"
yy159:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '2') goto yy166;
	goto yy13;
yy160:
	yyaccept = 2;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych == ':') goto yy167;
yy161:
#line 238 "../src/parse/lex.re"
	{
        msg.error(cur_loc(), "ill-formed header directive: expected"
            " `/*!header:re2c:<on|off>` followed by a space, a newline or the"
            " end of block `*" "/`");
        return INPUT_ERROR;
    }
#line 852 "src/parse/lex.cc"
yy162:
	yyaccept = 3;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= '\r') {
		if (yych <= 0x08) goto yy163;
		if (yych <= '\n') {
			yyt1 = YYCURSOR;
			goto yy168;
		}
		if (yych >= '\r') {
			yyt1 = YYCURSOR;
			goto yy168;
		}
	} else {
		if (yych <= ' ') {
			if (yych >= ' ') {
				yyt1 = YYCURSOR;
				goto yy168;
			}
		} else {
			if (yych == '*') {
				yyt1 = YYCURSOR;
				goto yy170;
			}
		}
	}
yy163:
#line 263 "../src/parse/lex.re"
	{
        msg.error(cur_loc(), "ill-formed start of `ignore:re2c` block: expected"
            " a space, a newline, or the end of block `*" "/`");
        return INPUT_ERROR;
    }
#line 886 "src/parse/lex.cc"
yy164:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'c') goto yy171;
	goto yy13;
yy165:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy173;
	goto yy13;
yy166:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'c') goto yy174;
	goto yy13;
yy167:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'o') goto yy176;
	goto yy13;
yy168:
	++YYCURSOR;
	YYCURSOR = yyt1;
#line 257 "../src/parse/lex.re"
	{
        out.wraw(tok, ptr);
        // allows arbitrary garbage before the end of the comment
        if (!lex_end_of_block(out, true)) return INPUT_ERROR;
        goto next;
    }
#line 913 "src/parse/lex.cc"
yy170:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '/') goto yy168;
	goto yy13;
yy171:
	yyaccept = 4;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych == '\t') goto yy177;
	if (yych == ' ') goto yy177;
yy172:
#line 251 "../src/parse/lex.re"
	{
        msg.error(cur_loc(), "ill-formed include directive: expected"
            " `/*!include:re2c \"<file>\" *" "/`");
        return INPUT_ERROR;
    }
#line 930 "src/parse/lex.cc"
yy173:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '2') goto yy179;
	goto yy13;
yy174:
	++YYCURSOR;
#line 182 "../src/parse/lex.re"
	{
        out.wraw(tok, ptr);
        if (!lex_name_list(alc, &block_list)) return INPUT_ERROR;
        if (!lex_end_of_block(out)) return INPUT_ERROR;
        if (!opts->fFlag) {
            msg.error(cur_loc(), "`getstate:re2c` without `-f --storable-state` option");
            return INPUT_ERROR;
        } else if (opts->target == TARGET_CODE) {
            // User-defined state switch is generated as many times as needed.
            out.wdelay_stmt(opts->topIndent, code_state_goto(alc, block_list));
            out.state_goto = true;
        }
        goto next;
    }
#line 952 "src/parse/lex.cc"
yy176:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'f') goto yy180;
	if (yych == 'n') goto yy181;
	goto yy13;
yy177:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy177;
		goto yy13;
	} else {
		if (yych <= ' ') goto yy177;
		if (yych == '"') {
			yyt1 = YYCURSOR;
			goto yy183;
		}
		goto yy13;
	}
yy179:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'c') goto yy185;
	goto yy13;
yy180:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'f') goto yy187;
	goto yy13;
yy181:
	++YYCURSOR;
#line 223 "../src/parse/lex.re"
	{
        out.wraw(tok, ptr);
        out.header_mode(true);
        out.need_header = opts->target == TARGET_CODE;
        if (!lex_end_of_block(out)) return INPUT_ERROR;
        goto next;
    }
#line 991 "src/parse/lex.cc"
yy183:
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= '!') {
		if (yych <= 0x00) goto yy13;
		if (yych == '\n') goto yy13;
		goto yy183;
	} else {
		if (yych <= '"') goto yy189;
		if (yych == '\\') goto yy190;
		goto yy183;
	}
yy185:
	++YYCURSOR;
#line 175 "../src/parse/lex.re"
	{
        out.wraw(tok, ptr);
        if (!lex_name_list(alc, &block_list)) return INPUT_ERROR;
        if (!lex_max(out, MAX_NMATCH, block_list)) return INPUT_ERROR;
        goto next;
    }
#line 1014 "src/parse/lex.cc"
yy187:
	++YYCURSOR;
#line 231 "../src/parse/lex.re"
	{
        out.wraw(tok, ptr);
        out.header_mode(false);
        out.wdelay_stmt(0, code_line_info_input(alc, cur_loc()));
        if (!lex_end_of_block(out)) return INPUT_ERROR;
        goto next;
    }
#line 1025 "src/parse/lex.cc"
yy189:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '\r') {
		if (yych <= 0x08) goto yy13;
		if (yych <= '\n') {
			yyt2 = YYCURSOR;
			goto yy191;
		}
		if (yych <= '\f') goto yy13;
		yyt2 = YYCURSOR;
		goto yy191;
	} else {
		if (yych <= ' ') {
			if (yych <= 0x1F) goto yy13;
			yyt2 = YYCURSOR;
			goto yy191;
		} else {
			if (yych == '*') {
				yyt2 = YYCURSOR;
				goto yy193;
			}
			goto yy13;
		}
	}
yy190:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= 0x00) goto yy13;
	if (yych == '\n') goto yy13;
	goto yy183;
yy191:
	++YYCURSOR;
	x = yyt1;
	YYCURSOR = yyt2;
	y = yyt2;
#line 245 "../src/parse/lex.re"
	{
        out.wraw(tok, ptr);
        if (!lex_end_of_block(out)) return INPUT_ERROR;
        include(getstr(x + 1, y - 1));
        goto next;
    }
#line 1069 "src/parse/lex.cc"
yy193:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '/') goto yy191;
	goto yy13;
}
#line 290 "../src/parse/lex.re"

}

bool Scanner::lex_opt_name(std::string &name)
{
    tok = cur;

#line 1083 "src/parse/lex.cc"
{
	YYCTYPE yych;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128,   0,   0,   0,   0,   0,   0, 
		  0, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128,   0,   0,   0,   0, 128, 
		  0, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
	};
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = (YYCTYPE)*(YYMARKER = YYCURSOR);
	if (yych <= 0x1F) {
		if (yych <= '\n') {
			if (yych >= '\t') {
				yyt1 = YYCURSOR;
				goto yy197;
			}
		} else {
			if (yych == '\r') {
				yyt1 = YYCURSOR;
				goto yy197;
			}
		}
	} else {
		if (yych <= '*') {
			if (yych <= ' ') {
				yyt1 = YYCURSOR;
				goto yy197;
			}
			if (yych >= '*') {
				yyt1 = YYCURSOR;
				goto yy199;
			}
		} else {
			if (yych == ':') goto yy201;
		}
	}
yy196:
#line 297 "../src/parse/lex.re"
	{
        msg.error(cur_loc(), "ill-formed start of a block: expected a space, a"
            " newline, a colon followed by a block name, or the end of block `*"
            "/`");
        return false;
    }
#line 1156 "src/parse/lex.cc"
yy197:
	++YYCURSOR;
	YYCURSOR = yyt1;
#line 304 "../src/parse/lex.re"
	{ name.clear();              return true; }
#line 1162 "src/parse/lex.cc"
yy199:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '/') goto yy197;
yy200:
	YYCURSOR = YYMARKER;
	goto yy196;
yy201:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '^') {
		if (yych <= '@') goto yy200;
		if (yych >= '[') goto yy200;
	} else {
		if (yych == '`') goto yy200;
		if (yych >= '{') goto yy200;
	}
yy202:
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy202;
	}
	if (yych <= '\r') {
		if (yych <= 0x08) goto yy200;
		if (yych <= '\n') {
			yyt1 = YYCURSOR;
			goto yy204;
		}
		if (yych <= '\f') goto yy200;
		yyt1 = YYCURSOR;
	} else {
		if (yych <= ' ') {
			if (yych <= 0x1F) goto yy200;
			yyt1 = YYCURSOR;
		} else {
			if (yych == '*') {
				yyt1 = YYCURSOR;
				goto yy206;
			}
			goto yy200;
		}
	}
yy204:
	++YYCURSOR;
	YYCURSOR = yyt1;
#line 305 "../src/parse/lex.re"
	{ name.assign(tok + 1, cur); return true; }
#line 1210 "src/parse/lex.cc"
yy206:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '/') goto yy204;
	goto yy200;
}
#line 306 "../src/parse/lex.re"

}

bool Scanner::lex_name_list(code_alc_t &alc, BlockNameList **ptail)
{
    BlockNameList **phead = ptail;
loop:
    tok = cur;

#line 1226 "src/parse/lex.cc"
{
	YYCTYPE yych;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128,   0,   0,   0,   0,   0,   0, 
		  0, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128,   0,   0,   0,   0, 128, 
		  0, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
	};
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = (YYCTYPE)*(YYMARKER = YYCURSOR);
	if (yych <= 0x1F) {
		if (yych <= '\n') {
			if (yych >= '\t') {
				yyt1 = YYCURSOR;
				goto yy210;
			}
		} else {
			if (yych == '\r') {
				yyt1 = YYCURSOR;
				goto yy210;
			}
		}
	} else {
		if (yych <= '*') {
			if (yych <= ' ') {
				yyt1 = YYCURSOR;
				goto yy210;
			}
			if (yych >= '*') {
				yyt1 = YYCURSOR;
				goto yy212;
			}
		} else {
			if (yych == ':') goto yy214;
		}
	}
yy209:
#line 315 "../src/parse/lex.re"
	{
        msg.error(cur_loc(), "ill-formed start of a block: expected a space, a"
            " newline, a colon followed by a list of colon-separated block"
            " names, or the end of block `*" "/`");
        return false;
    }
#line 1299 "src/parse/lex.cc"
yy210:
	++YYCURSOR;
	YYCURSOR = yyt1;
#line 322 "../src/parse/lex.re"
	{
        *ptail = NULL;
        return true;
    }
#line 1308 "src/parse/lex.cc"
yy212:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '/') goto yy210;
yy213:
	YYCURSOR = YYMARKER;
	goto yy209;
yy214:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '^') {
		if (yych <= '@') goto yy213;
		if (yych >= '[') goto yy213;
	} else {
		if (yych == '`') goto yy213;
		if (yych >= '{') goto yy213;
	}
yy215:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy215;
	}
#line 327 "../src/parse/lex.re"
	{
        BlockNameList *l = alc.alloct<BlockNameList>(1);
        l->name = newcstr(tok + 1, cur, alc);
        l->next = NULL;
        *ptail = l;
        ptail = &l->next;

        // Check that the added name is unique.
        for (const BlockNameList *p = *phead; p != l; p = p->next) {
            if (strcmp(p->name, l->name) == 0) {
                msg.error(cur_loc(), "duplicate block '%s' on the list", p->name);
                return false;
            }
        }

        goto loop;
    }
#line 1349 "src/parse/lex.cc"
}
#line 344 "../src/parse/lex.re"

}

bool Scanner::lex_end_of_block(Output &out, bool allow_garbage)
{
    bool multiline = false;
loop:

#line 1360 "src/parse/lex.cc"
{
	YYCTYPE yych;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0, 128,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		128,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
	};
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy222;
	}
	if (yych <= '\f') {
		if (yych <= 0x08) goto yy220;
		if (yych <= '\n') goto yy225;
	} else {
		if (yych <= '\r') goto yy227;
		if (yych == '*') goto yy228;
	}
yy220:
	++YYCURSOR;
yy221:
#line 352 "../src/parse/lex.re"
	{
        if (allow_garbage && !is_eof()) goto loop;
        msg.error(cur_loc(), "ill-formed end of block: expected optional"
            " whitespaces followed by `*" "/`");
        return false;
    }
#line 1419 "src/parse/lex.cc"
yy222:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy222;
	}
#line 362 "../src/parse/lex.re"
	{ goto loop; }
#line 1429 "src/parse/lex.cc"
yy225:
	++YYCURSOR;
#line 363 "../src/parse/lex.re"
	{ next_line(); multiline = true; goto loop; }
#line 1434 "src/parse/lex.cc"
yy227:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy225;
	goto yy221;
yy228:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych != '/') goto yy221;
	++YYCURSOR;
#line 358 "../src/parse/lex.re"
	{
        if (multiline) out.wdelay_stmt(0, code_line_info_input(out.allocator, cur_loc()));
        return true;
    }
#line 1448 "src/parse/lex.cc"
}
#line 364 "../src/parse/lex.re"

}

bool Scanner::lex_max(Output &out, MaxDirectiveKind kind, BlockNameList *blocks)
{
    code_alc_t &alc = out.allocator;
    bool multiline = false;
    const char *format = NULL;
loop:

#line 1461 "src/parse/lex.cc"
{
	YYCTYPE yych;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0, 128,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		128,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
	};
	if ((YYLIMIT - YYCURSOR) < 6) YYFILL(6);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy235;
	}
	if (yych <= '\r') {
		if (yych <= 0x08) goto yy233;
		if (yych <= '\n') goto yy238;
		if (yych >= '\r') goto yy240;
	} else {
		if (yych <= '*') {
			if (yych >= '*') goto yy241;
		} else {
			if (yych == 'f') goto yy242;
		}
	}
yy233:
	++YYCURSOR;
yy234:
#line 374 "../src/parse/lex.re"
	{
        msg.error(cur_loc(), "ill-formed directive: expected an optional "
            "configuration 'format' followed by the end of block `*" "/`");
        return false;
    }
#line 1523 "src/parse/lex.cc"
yy235:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy235;
	}
#line 385 "../src/parse/lex.re"
	{ goto loop; }
#line 1533 "src/parse/lex.cc"
yy238:
	++YYCURSOR;
#line 386 "../src/parse/lex.re"
	{ next_line(); multiline = true; goto loop; }
#line 1538 "src/parse/lex.cc"
yy240:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy238;
	goto yy234;
yy241:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '/') goto yy243;
	goto yy234;
yy242:
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych == 'o') goto yy245;
	goto yy234;
yy243:
	++YYCURSOR;
#line 379 "../src/parse/lex.re"
	{
        out.wdelay_stmt(0, code_yymax(alc, kind, blocks, format));
        if (multiline) out.wdelay_stmt(0, code_line_info_input(alc, cur_loc()));
        return true;
    }
#line 1559 "src/parse/lex.cc"
yy245:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'r') goto yy247;
yy246:
	YYCURSOR = YYMARKER;
	goto yy234;
yy247:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych != 'm') goto yy246;
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych != 'a') goto yy246;
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych != 't') goto yy246;
	++YYCURSOR;
#line 384 "../src/parse/lex.re"
	{ format = copystr(lex_conf_string(), alc); goto loop; }
#line 1576 "src/parse/lex.cc"
}
#line 387 "../src/parse/lex.re"

}

bool Scanner::lex_tags(Output &out, BlockNameList *blocks, bool mtags)
{
    const opt_t *opts = out.block().opts;
    std::string fmt, sep;
loop:

#line 1588 "src/parse/lex.cc"
{
	YYCTYPE yych;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0, 128,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		128,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
	};
	if ((YYLIMIT - YYCURSOR) < 9) YYFILL(9);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy256;
	}
	if (yych <= ')') {
		if (yych <= '\n') {
			if (yych >= '\t') goto yy259;
		} else {
			if (yych == '\r') goto yy261;
		}
	} else {
		if (yych <= 'f') {
			if (yych <= '*') goto yy262;
			if (yych >= 'f') goto yy263;
		} else {
			if (yych == 's') goto yy264;
		}
	}
	++YYCURSOR;
yy255:
#line 396 "../src/parse/lex.re"
	{
        msg.error(cur_loc(), "unrecognized configuration");
        return false;
    }
#line 1651 "src/parse/lex.cc"
yy256:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy256;
	}
#line 404 "../src/parse/lex.re"
	{ goto loop; }
#line 1661 "src/parse/lex.cc"
yy259:
	++YYCURSOR;
#line 405 "../src/parse/lex.re"
	{ next_line(); goto loop; }
#line 1666 "src/parse/lex.cc"
yy261:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy259;
	goto yy255;
yy262:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '/') goto yy265;
	goto yy255;
yy263:
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych == 'o') goto yy267;
	goto yy255;
yy264:
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych == 'e') goto yy269;
	goto yy255;
yy265:
	++YYCURSOR;
#line 406 "../src/parse/lex.re"
	{
        if (opts->target == TARGET_CODE) {
            out.wdelay_stmt(opts->topIndent,
                code_tags(out.allocator, fmt, sep, blocks, mtags));
        }
        return true;
    }
#line 1693 "src/parse/lex.cc"
yy267:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'r') goto yy270;
yy268:
	YYCURSOR = YYMARKER;
	goto yy255;
yy269:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'p') goto yy271;
	goto yy268;
yy270:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'm') goto yy272;
	goto yy268;
yy271:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'a') goto yy273;
	goto yy268;
yy272:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'a') goto yy274;
	goto yy268;
yy273:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'r') goto yy275;
	goto yy268;
yy274:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 't') goto yy276;
	goto yy268;
yy275:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'a') goto yy278;
	goto yy268;
yy276:
	++YYCURSOR;
#line 401 "../src/parse/lex.re"
	{ fmt = lex_conf_string(); goto loop; }
#line 1732 "src/parse/lex.cc"
yy278:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych != 't') goto yy268;
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych != 'o') goto yy268;
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych != 'r') goto yy268;
	++YYCURSOR;
#line 402 "../src/parse/lex.re"
	{ sep = lex_conf_string(); goto loop; }
#line 1743 "src/parse/lex.cc"
}
#line 413 "../src/parse/lex.re"

}

int Scanner::scan()
{
    const char *p, *x, *y;
scan:
    tok = cur;
    location = cur_loc();

#line 1756 "src/parse/lex.cc"
{
	YYCTYPE yych;
	unsigned int yyaccept = 0;
	static const unsigned char yybm[] = {
		  0, 128, 128, 128, 128, 128, 128, 128, 
		128, 144,   0, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		144, 128,   0, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		224, 224, 224, 224, 224, 224, 224, 224, 
		224, 224, 128, 128, 128, 128, 128, 128, 
		128, 160, 160, 160, 160, 160, 160, 160, 
		160, 160, 160, 160, 160, 160, 160, 160, 
		160, 160, 160, 160, 160, 160, 160, 160, 
		160, 160, 160, 128,   0, 128, 128, 160, 
		128, 160, 160, 160, 160, 160, 160, 160, 
		160, 160, 160, 160, 160, 160, 160, 160, 
		160, 160, 160, 160, 160, 160, 160, 160, 
		160, 160, 160, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
	};
	if ((YYLIMIT - YYCURSOR) < 9) YYFILL(9);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy287;
	}
	if (yych <= '9') {
		if (yych <= '$') {
			if (yych <= '\r') {
				if (yych <= 0x08) goto yy285;
				if (yych <= '\n') goto yy290;
				if (yych >= '\r') goto yy292;
			} else {
				if (yych <= '!') {
					if (yych >= ' ') goto yy293;
				} else {
					if (yych <= '"') goto yy294;
					if (yych <= '#') goto yy296;
					goto yy297;
				}
			}
		} else {
			if (yych <= '*') {
				if (yych <= '&') {
					if (yych <= '%') goto yy299;
				} else {
					if (yych <= '\'') goto yy300;
					if (yych <= ')') goto yy297;
					goto yy302;
				}
			} else {
				if (yych <= '-') {
					if (yych <= '+') goto yy297;
				} else {
					if (yych <= '.') goto yy303;
					if (yych <= '/') goto yy305;
				}
			}
		}
	} else {
		if (yych <= '[') {
			if (yych <= '=') {
				if (yych <= ':') goto yy306;
				if (yych <= ';') goto yy297;
				if (yych <= '<') goto yy307;
				goto yy309;
			} else {
				if (yych <= '?') {
					if (yych >= '?') goto yy297;
				} else {
					if (yych <= '@') goto yy296;
					if (yych <= 'Z') goto yy310;
					goto yy313;
				}
			}
		} else {
			if (yych <= 'q') {
				if (yych <= '^') {
					if (yych <= '\\') goto yy297;
				} else {
					if (yych != '`') goto yy310;
				}
			} else {
				if (yych <= 'z') {
					if (yych <= 'r') goto yy315;
					goto yy310;
				} else {
					if (yych <= '{') goto yy316;
					if (yych <= '|') goto yy297;
				}
			}
		}
	}
yy285:
	++YYCURSOR;
yy286:
#line 565 "../src/parse/lex.re"
	{
        msg.error(tok_loc(), "unexpected character: '%c'", *tok);
        exit(1);
    }
#line 1874 "src/parse/lex.cc"
yy287:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 16) {
		goto yy287;
	}
#line 547 "../src/parse/lex.re"
	{ goto scan; }
#line 1884 "src/parse/lex.cc"
yy290:
	yyaccept = 0;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy318;
	} else {
		if (yych <= ' ') goto yy318;
		if (yych == '#') goto yy321;
	}
yy291:
#line 554 "../src/parse/lex.re"
	{
        next_line();
        if (lexer_state == LEX_FLEX_NAME) {
            lexer_state = LEX_NORMAL;
            return TOKEN_FID_END;
        }
        else {
            goto scan;
        }
    }
#line 1906 "src/parse/lex.cc"
yy292:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy290;
	goto yy286;
yy293:
	yyaccept = 1;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych == 'i') goto yy323;
	if (yych == 'u') goto yy324;
	goto yy286;
yy294:
	++YYCURSOR;
#line 439 "../src/parse/lex.re"
	{ yylval.regexp = lex_str('"'); return TOKEN_REGEXP; }
#line 1921 "src/parse/lex.cc"
yy296:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '^') {
		if (yych <= '@') goto yy286;
		if (yych <= 'Z') goto yy325;
		goto yy286;
	} else {
		if (yych == '`') goto yy286;
		if (yych <= 'z') goto yy325;
		goto yy286;
	}
yy297:
	++YYCURSOR;
yy298:
#line 448 "../src/parse/lex.re"
	{ return *tok; }
#line 1938 "src/parse/lex.cc"
yy299:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '}') goto yy328;
	goto yy286;
yy300:
	++YYCURSOR;
#line 438 "../src/parse/lex.re"
	{ yylval.regexp = lex_str('\''); return TOKEN_REGEXP; }
#line 1947 "src/parse/lex.cc"
yy302:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '/') goto yy328;
	goto yy298;
yy303:
	++YYCURSOR;
#line 542 "../src/parse/lex.re"
	{
        yylval.regexp = ast_dot(tok_loc());
        return TOKEN_REGEXP;
    }
#line 1959 "src/parse/lex.cc"
yy305:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '*') goto yy330;
	if (yych == '/') goto yy332;
	goto yy298;
yy306:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '=') goto yy334;
	goto yy286;
yy307:
	++YYCURSOR;
#line 431 "../src/parse/lex.re"
	{ return lex_clist(); }
#line 1973 "src/parse/lex.cc"
yy309:
	yyaccept = 2;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych == '>') goto yy336;
	goto yy298;
yy310:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
yy311:
	if (yybm[0+yych] & 32) {
		goto yy310;
	}
#line 497 "../src/parse/lex.re"
	{
        if (!globopts->FFlag || lex_namedef_context_re2c()) {
            yylval.str = newstr(tok, cur);
            return TOKEN_ID;
        }
        else if (lex_namedef_context_flex()) {
            yylval.str = newstr(tok, cur);
            lexer_state = LEX_FLEX_NAME;
            return TOKEN_FID;
        }
        else {
            // consume one character, otherwise we risk breaking operator
            // precedence in cases like ab*: it should be a(b)*, not (ab)*
            cur = tok + 1;

            ASTChar c = {static_cast<uint8_t>(tok[0]), tok_loc()};
            std::vector<ASTChar> *str = new std::vector<ASTChar>;
            str->push_back(c);
            yylval.regexp = ast_str(tok_loc(), str, false);
            return TOKEN_REGEXP;
        }
    }
#line 2010 "src/parse/lex.cc"
yy313:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '^') goto yy338;
#line 440 "../src/parse/lex.re"
	{ yylval.regexp = lex_cls(false); return TOKEN_REGEXP; }
#line 2016 "src/parse/lex.cc"
yy315:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy340;
	goto yy311;
yy316:
	yyaccept = 3;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 64) {
		goto yy343;
	}
	if (yych <= 'Z') {
		if (yych == ',') goto yy341;
		if (yych >= 'A') goto yy345;
	} else {
		if (yych <= '_') {
			if (yych >= '_') goto yy345;
		} else {
			if (yych <= '`') goto yy317;
			if (yych <= 'z') goto yy345;
		}
	}
yy317:
#line 423 "../src/parse/lex.re"
	{ lex_code_in_braces(); return TOKEN_CODE; }
#line 2041 "src/parse/lex.cc"
yy318:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy318;
	} else {
		if (yych <= ' ') goto yy318;
		if (yych == '#') goto yy321;
	}
yy320:
	YYCURSOR = YYMARKER;
	if (yyaccept <= 3) {
		if (yyaccept <= 1) {
			if (yyaccept == 0) {
				goto yy291;
			} else {
				goto yy286;
			}
		} else {
			if (yyaccept == 2) {
				goto yy298;
			} else {
				goto yy317;
			}
		}
	} else {
		if (yyaccept <= 5) {
			if (yyaccept == 4) {
				goto yy335;
			} else {
				goto yy342;
			}
		} else {
			if (yyaccept == 6) {
				goto yy362;
			} else {
				goto yy386;
			}
		}
	}
yy321:
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 5) YYFILL(5);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy321;
		goto yy320;
	} else {
		if (yych <= ' ') goto yy321;
		if (yych == 'l') goto yy347;
		goto yy320;
	}
yy323:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'n') goto yy348;
	goto yy320;
yy324:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 's') goto yy349;
	goto yy320;
yy325:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= 'Z') {
		if (yych <= '/') goto yy327;
		if (yych <= '9') goto yy325;
		if (yych >= 'A') goto yy325;
	} else {
		if (yych <= '_') {
			if (yych >= '_') goto yy325;
		} else {
			if (yych <= '`') goto yy327;
			if (yych <= 'z') goto yy325;
		}
	}
yy327:
#line 443 "../src/parse/lex.re"
	{
        yylval.regexp = ast_tag(tok_loc(), newstr(tok + 1, cur), tok[0] == '#');
        return TOKEN_REGEXP;
    }
#line 2125 "src/parse/lex.cc"
yy328:
	++YYCURSOR;
#line 436 "../src/parse/lex.re"
	{ tok = cur; return 0; }
#line 2130 "src/parse/lex.cc"
yy330:
	++YYCURSOR;
#line 434 "../src/parse/lex.re"
	{ lex_c_comment(); goto scan; }
#line 2135 "src/parse/lex.cc"
yy332:
	++YYCURSOR;
#line 433 "../src/parse/lex.re"
	{ lex_cpp_comment(); goto scan; }
#line 2140 "src/parse/lex.cc"
yy334:
	yyaccept = 4;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych == '>') goto yy336;
yy335:
#line 424 "../src/parse/lex.re"
	{ lex_code_indented(); return TOKEN_CODE; }
#line 2148 "src/parse/lex.cc"
yy336:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= '@') {
		if (yych <= '\t') {
			if (yych <= 0x08) goto yy320;
			goto yy336;
		} else {
			if (yych == ' ') goto yy336;
			goto yy320;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'Z') {
				yyt1 = YYCURSOR;
				goto yy350;
			}
			if (yych <= '^') goto yy320;
			yyt1 = YYCURSOR;
			goto yy350;
		} else {
			if (yych <= '`') goto yy320;
			if (yych <= 'z') {
				yyt1 = YYCURSOR;
				goto yy350;
			}
			goto yy320;
		}
	}
yy338:
	++YYCURSOR;
#line 441 "../src/parse/lex.re"
	{ yylval.regexp = lex_cls(true);  return TOKEN_REGEXP; }
#line 2183 "src/parse/lex.cc"
yy340:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '2') goto yy353;
	goto yy311;
yy341:
	++YYCURSOR;
yy342:
#line 480 "../src/parse/lex.re"
	{
        msg.error(tok_loc(), "illegal closure form, use '{n}', '{n,}', '{n,m}' "
            "where n and m are numbers");
        exit(1);
    }
#line 2197 "src/parse/lex.cc"
yy343:
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 64) {
		goto yy343;
	}
	if (yych == ',') {
		yyt1 = YYCURSOR;
		goto yy354;
	}
	if (yych == '}') goto yy355;
	goto yy320;
yy345:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= '^') {
		if (yych <= '9') {
			if (yych <= '/') goto yy320;
			goto yy345;
		} else {
			if (yych <= '@') goto yy320;
			if (yych <= 'Z') goto yy345;
			goto yy320;
		}
	} else {
		if (yych <= 'z') {
			if (yych == '`') goto yy320;
			goto yy345;
		} else {
			if (yych == '}') goto yy357;
			goto yy320;
		}
	}
yy347:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'i') goto yy359;
	goto yy320;
yy348:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'c') goto yy360;
	goto yy320;
yy349:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy361;
	goto yy320;
yy350:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= 'Z') {
		if (yych <= '/') goto yy352;
		if (yych <= '9') goto yy350;
		if (yych >= 'A') goto yy350;
	} else {
		if (yych <= '_') {
			if (yych >= '_') goto yy350;
		} else {
			if (yych <= '`') goto yy352;
			if (yych <= 'z') goto yy350;
		}
	}
yy352:
	p = yyt1;
#line 426 "../src/parse/lex.re"
	{
        yylval.str = newstr(p, cur);
        return tok[0] == ':' ? TOKEN_CJUMP : TOKEN_CNEXT;
    }
#line 2268 "src/parse/lex.cc"
yy353:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'c') goto yy363;
	goto yy311;
yy354:
	yyaccept = 5;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= '/') goto yy342;
	if (yych <= '9') goto yy364;
	if (yych == '}') goto yy366;
	goto yy342;
yy355:
	++YYCURSOR;
#line 450 "../src/parse/lex.re"
	{
        if (!s_to_u32_unsafe (tok + 1, cur - 1, yylval.bounds.min)) {
            msg.error(tok_loc(), "repetition count overflow");
            exit(1);
        }
        yylval.bounds.max = yylval.bounds.min;
        return TOKEN_CLOSESIZE;
    }
#line 2291 "src/parse/lex.cc"
yy357:
	++YYCURSOR;
#line 486 "../src/parse/lex.re"
	{
        if (!globopts->FFlag) {
            msg.error(tok_loc(), "curly braces for names only allowed with -F switch");
            exit(1);
        }
        yylval.str = newstr(tok + 1, cur - 1);
        return TOKEN_ID;
    }
#line 2303 "src/parse/lex.cc"
yy359:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'n') goto yy368;
	goto yy320;
yy360:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'l') goto yy369;
	goto yy320;
yy361:
	yyaccept = 6;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych == ':') goto yy370;
yy362:
#line 536 "../src/parse/lex.re"
	{
        msg.error(tok_loc(), "ill-formed use directive"
            ", expected format: `!use:<block-name> ; <newline>`");
        exit(1);
    }
#line 2323 "src/parse/lex.cc"
yy363:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == ':') goto yy371;
	goto yy311;
yy364:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= '/') goto yy320;
	if (yych <= '9') goto yy364;
	if (yych == '}') goto yy373;
	goto yy320;
yy366:
	++YYCURSOR;
#line 471 "../src/parse/lex.re"
	{
        if (!s_to_u32_unsafe (tok + 1, cur - 2, yylval.bounds.min)) {
            msg.error(tok_loc(), "repetition lower bound overflow");
            exit(1);
        }
        yylval.bounds.max = std::numeric_limits<uint32_t>::max();
        return TOKEN_CLOSESIZE;
    }
#line 2347 "src/parse/lex.cc"
yy368:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy375;
	goto yy320;
yy369:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'u') goto yy376;
	goto yy320;
yy370:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '^') {
		if (yych <= '@') goto yy320;
		if (yych <= 'Z') {
			yyt1 = YYCURSOR;
			goto yy377;
		}
		goto yy320;
	} else {
		if (yych == '`') goto yy320;
		if (yych <= 'z') {
			yyt1 = YYCURSOR;
			goto yy377;
		}
		goto yy320;
	}
yy371:
	++YYCURSOR;
#line 495 "../src/parse/lex.re"
	{ return TOKEN_CONF; }
#line 2377 "src/parse/lex.cc"
yy373:
	++YYCURSOR;
	p = yyt1;
#line 459 "../src/parse/lex.re"
	{
        if (!s_to_u32_unsafe (tok + 1, p, yylval.bounds.min)) {
            msg.error(tok_loc(), "repetition lower bound overflow");
            exit(1);
        }
        if (!s_to_u32_unsafe (p + 1, cur - 1, yylval.bounds.max)) {
            msg.error(tok_loc(), "repetition upper bound overflow");
            exit(1);
        }
        return TOKEN_CLOSESIZE;
    }
#line 2393 "src/parse/lex.cc"
yy375:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '0') goto yy380;
	if (yych <= '9') goto yy320;
	goto yy380;
yy376:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'd') goto yy381;
	goto yy320;
yy377:
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= '@') {
		if (yych <= '9') {
			if (yych <= '/') goto yy320;
			goto yy377;
		} else {
			if (yych == ';') {
				yyt2 = YYCURSOR;
				goto yy382;
			}
			goto yy320;
		}
	} else {
		if (yych <= '_') {
			if (yych <= 'Z') goto yy377;
			if (yych <= '^') goto yy320;
			goto yy377;
		} else {
			if (yych <= '`') goto yy320;
			if (yych <= 'z') goto yy377;
			goto yy320;
		}
	}
yy379:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
yy380:
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy379;
		goto yy320;
	} else {
		if (yych <= ' ') goto yy379;
		if (yych <= '0') goto yy320;
		if (yych <= '9') {
			yyt1 = YYCURSOR;
			goto yy383;
		}
		goto yy320;
	}
yy381:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == 'e') goto yy385;
	goto yy320;
yy382:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy387;
	if (yych == '\r') goto yy389;
	goto yy320;
yy383:
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= '\r') {
		if (yych <= '\t') {
			if (yych <= 0x08) goto yy320;
			goto yy390;
		} else {
			if (yych <= '\n') goto yy392;
			if (yych <= '\f') goto yy320;
			goto yy394;
		}
	} else {
		if (yych <= ' ') {
			if (yych <= 0x1F) goto yy320;
			goto yy390;
		} else {
			if (yych <= '/') goto yy320;
			if (yych <= '9') goto yy383;
			goto yy320;
		}
	}
yy385:
	yyaccept = 7;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych == '\t') goto yy395;
	if (yych == ' ') goto yy395;
yy386:
#line 525 "../src/parse/lex.re"
	{
        msg.error(tok_loc(), "ill-formed include directive"
            ", expected format: `!include \"<file>\" ; <newline>`");
        exit(1);
    }
#line 2490 "src/parse/lex.cc"
yy387:
	++YYCURSOR;
	x = yyt1;
	y = yyt2;
#line 531 "../src/parse/lex.re"
	{
        next_line();
        yylval.str = newstr(x, y); // save the name of the used block
        return TOKEN_BLOCK;
    }
#line 2501 "src/parse/lex.cc"
yy389:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy387;
	goto yy320;
yy390:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy390;
		goto yy320;
	} else {
		if (yych <= ' ') goto yy390;
		if (yych == '"') goto yy397;
		goto yy320;
	}
yy392:
	++YYCURSOR;
	YYCURSOR = yyt1;
#line 549 "../src/parse/lex.re"
	{
        set_sourceline ();
        return TOKEN_LINE_INFO;
    }
#line 2526 "src/parse/lex.cc"
yy394:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy392;
	goto yy320;
yy395:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy395;
		goto yy320;
	} else {
		if (yych <= ' ') goto yy395;
		if (yych == '"') {
			yyt1 = YYCURSOR;
			goto yy399;
		}
		goto yy320;
	}
yy397:
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy397;
	}
	if (yych <= '\n') goto yy320;
	if (yych <= '"') goto yy401;
	goto yy402;
yy399:
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= '!') {
		if (yych <= 0x00) goto yy320;
		if (yych == '\n') goto yy320;
		goto yy399;
	} else {
		if (yych <= '"') goto yy403;
		if (yych == '\\') goto yy404;
		goto yy399;
	}
yy401:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy392;
	if (yych == '\r') goto yy394;
	goto yy320;
yy402:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= 0x00) goto yy320;
	if (yych == '\n') goto yy320;
	goto yy397;
yy403:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= 0x1F) {
		if (yych == '\t') {
			yyt2 = YYCURSOR;
			goto yy405;
		}
		goto yy320;
	} else {
		if (yych <= ' ') {
			yyt2 = YYCURSOR;
			goto yy405;
		}
		if (yych == ';') {
			yyt2 = YYCURSOR;
			goto yy407;
		}
		goto yy320;
	}
yy404:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= 0x00) goto yy320;
	if (yych == '\n') goto yy320;
	goto yy399;
yy405:
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy405;
		goto yy320;
	} else {
		if (yych <= ' ') goto yy405;
		if (yych != ';') goto yy320;
	}
yy407:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy408;
	if (yych == '\r') goto yy410;
	goto yy320;
yy408:
	++YYCURSOR;
	x = yyt1;
	y = yyt2;
#line 520 "../src/parse/lex.re"
	{
        next_line();
        include(getstr(x + 1, y - 1));
        goto scan;
    }
#line 2633 "src/parse/lex.cc"
yy410:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy408;
	goto yy320;
}
#line 569 "../src/parse/lex.re"

}

bool Scanner::lex_namedef_context_re2c()
{

#line 2646 "src/parse/lex.cc"
{
	YYCTYPE yych;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0, 128,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		128,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
	};
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = (YYCTYPE)*(YYMARKER = YYCURSOR);
	if (yych <= 0x1F) {
		if (yych == '\t') {
			yyt1 = YYCURSOR;
			goto yy414;
		}
	} else {
		if (yych <= ' ') {
			yyt1 = YYCURSOR;
			goto yy414;
		}
		if (yych == '=') {
			yyt1 = YYCURSOR;
			goto yy417;
		}
	}
yy413:
#line 576 "../src/parse/lex.re"
	{ return false; }
#line 2703 "src/parse/lex.cc"
yy414:
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy414;
	}
	if (yych == '=') goto yy417;
yy416:
	YYCURSOR = YYMARKER;
	goto yy413;
yy417:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '>') goto yy416;
	++YYCURSOR;
	YYCURSOR = yyt1;
#line 575 "../src/parse/lex.re"
	{ return true; }
#line 2722 "src/parse/lex.cc"
}
#line 577 "../src/parse/lex.re"

}

bool Scanner::lex_namedef_context_flex()
{

#line 2731 "src/parse/lex.cc"
{
	YYCTYPE yych;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0, 128,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		128,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
	};
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych == '\t') {
		yyt1 = YYCURSOR;
		goto yy423;
	}
	if (yych == ' ') {
		yyt1 = YYCURSOR;
		goto yy423;
	}
#line 585 "../src/parse/lex.re"
	{ return false; }
#line 2780 "src/parse/lex.cc"
yy423:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy423;
	}
	if (yych <= '<') {
		if (yych == ':') goto yy426;
	} else {
		if (yych <= '=') goto yy426;
		if (yych == '{') goto yy426;
	}
	YYCURSOR = yyt1;
#line 584 "../src/parse/lex.re"
	{ return true; }
#line 2797 "src/parse/lex.cc"
yy426:
	++YYCURSOR;
	YYCURSOR = yyt1;
#line 583 "../src/parse/lex.re"
	{ return false; }
#line 2803 "src/parse/lex.cc"
}
#line 586 "../src/parse/lex.re"

}

int Scanner::lex_clist()
{
    int kind = TOKEN_CLIST;
    CondList *cl = new CondList;

#line 2814 "src/parse/lex.cc"
{
	YYCTYPE yych;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0, 128,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		128,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
	};
	goto yy428;
yy429:
	++YYCURSOR;
yy428:
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy429;
	}
	if (yych <= 0x1F) goto yy431;
	if (yych <= '!') goto yy432;
	if (yych == '>') goto yy435;
yy431:
#line 596 "../src/parse/lex.re"
	{ goto cond; }
#line 2866 "src/parse/lex.cc"
yy432:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych == '\t') goto yy432;
	if (yych == ' ') goto yy432;
#line 594 "../src/parse/lex.re"
	{ kind = TOKEN_CSETUP; goto cond; }
#line 2875 "src/parse/lex.cc"
yy435:
	++YYCURSOR;
#line 595 "../src/parse/lex.re"
	{ kind = TOKEN_CZERO; goto end; }
#line 2880 "src/parse/lex.cc"
}
#line 597 "../src/parse/lex.re"

cond:
    tok = cur;

#line 2887 "src/parse/lex.cc"
{
	YYCTYPE yych;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128,   0,   0,   0,   0,   0,   0, 
		  0, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128,   0,   0,   0,   0, 128, 
		  0, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
	};
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= 'Z') {
		if (yych == '*') goto yy441;
		if (yych >= 'A') goto yy443;
	} else {
		if (yych <= '_') {
			if (yych >= '_') goto yy443;
		} else {
			if (yych <= '`') goto yy439;
			if (yych <= 'z') goto yy443;
		}
	}
yy439:
	++YYCURSOR;
#line 603 "../src/parse/lex.re"
	{ goto error; }
#line 2941 "src/parse/lex.cc"
yy441:
	++YYCURSOR;
#line 602 "../src/parse/lex.re"
	{ if (!cl->empty()) goto error; cl->insert("*"); goto next; }
#line 2946 "src/parse/lex.cc"
yy443:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy443;
	}
#line 601 "../src/parse/lex.re"
	{ cl->insert(getstr(tok, cur)); goto next; }
#line 2956 "src/parse/lex.cc"
}
#line 604 "../src/parse/lex.re"

next:

#line 2962 "src/parse/lex.cc"
{
	YYCTYPE yych;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0, 128,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		128,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
	};
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= ' ') {
		if (yych == '\t') goto yy450;
		if (yych >= ' ') goto yy450;
	} else {
		if (yych <= ',') {
			if (yych >= ',') goto yy451;
		} else {
			if (yych == '>') goto yy454;
		}
	}
	++YYCURSOR;
yy449:
#line 609 "../src/parse/lex.re"
	{ goto error; }
#line 3015 "src/parse/lex.cc"
yy450:
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= ' ') {
		if (yych == '\t') goto yy456;
		if (yych <= 0x1F) goto yy449;
		goto yy456;
	} else {
		if (yych <= ',') {
			if (yych <= '+') goto yy449;
		} else {
			if (yych == '>') goto yy454;
			goto yy449;
		}
	}
yy451:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy451;
	}
#line 607 "../src/parse/lex.re"
	{ goto cond; }
#line 3039 "src/parse/lex.cc"
yy454:
	++YYCURSOR;
#line 608 "../src/parse/lex.re"
	{ goto end; }
#line 3044 "src/parse/lex.cc"
yy456:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= ' ') {
		if (yych == '\t') goto yy456;
		if (yych >= ' ') goto yy456;
	} else {
		if (yych <= ',') {
			if (yych >= ',') goto yy451;
		} else {
			if (yych == '>') goto yy454;
		}
	}
	YYCURSOR = YYMARKER;
	goto yy449;
}
#line 610 "../src/parse/lex.re"

end:
    yylval.clist = cl;
    return kind;
error:
    delete cl;
    msg.error(cur_loc(), "syntax error in condition list");
    exit(1);
}

void Scanner::lex_code_indented()
{
    const loc_t &loc = tok_loc();
    tok = cur;
code:

#line 3079 "src/parse/lex.cc"
{
	YYCTYPE yych;
	if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= '&') {
		if (yych <= '\f') {
			if (yych <= 0x00) goto yy461;
			if (yych == '\n') goto yy465;
			goto yy463;
		} else {
			if (yych <= '\r') goto yy467;
			if (yych == '"') goto yy468;
			goto yy463;
		}
	} else {
		if (yych <= 'z') {
			if (yych <= '\'') goto yy468;
			if (yych == '/') goto yy470;
			goto yy463;
		} else {
			if (yych == '|') goto yy463;
			if (yych <= '}') goto yy471;
			goto yy463;
		}
	}
yy461:
	++YYCURSOR;
#line 636 "../src/parse/lex.re"
	{ fail_if_eof(); goto code; }
#line 3109 "src/parse/lex.cc"
yy463:
	++YYCURSOR;
yy464:
#line 644 "../src/parse/lex.re"
	{ goto code; }
#line 3115 "src/parse/lex.cc"
yy465:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '\f') {
		if (yych <= 0x08) goto yy466;
		if (yych <= '\n') goto yy473;
	} else {
		if (yych <= '\r') goto yy473;
		if (yych == ' ') goto yy473;
	}
yy466:
#line 627 "../src/parse/lex.re"
	{
        next_line();
        while (isspace(tok[0])) ++tok;
        char *p = cur;
        while (p > tok && isspace(p[-1])) --p;
        yylval.semact = new SemAct(loc, getstr(tok, p));
        return;
    }
#line 3135 "src/parse/lex.cc"
yy467:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy465;
	goto yy464;
yy468:
	++YYCURSOR;
#line 643 "../src/parse/lex.re"
	{ lex_string(cur[-1]); goto code; }
#line 3144 "src/parse/lex.cc"
yy470:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '*') goto yy475;
	if (yych == '/') goto yy477;
	goto yy464;
yy471:
	++YYCURSOR;
#line 637 "../src/parse/lex.re"
	{
        msg.error(cur_loc(), "Curly braces are not allowed after ':='");
        exit(1);
    }
#line 3157 "src/parse/lex.cc"
yy473:
	++YYCURSOR;
	YYCURSOR -= 1;
#line 626 "../src/parse/lex.re"
	{ next_line(); goto code; }
#line 3163 "src/parse/lex.cc"
yy475:
	++YYCURSOR;
#line 641 "../src/parse/lex.re"
	{ lex_c_comment(); goto code; }
#line 3168 "src/parse/lex.cc"
yy477:
	++YYCURSOR;
#line 642 "../src/parse/lex.re"
	{ lex_cpp_comment(); goto code; }
#line 3173 "src/parse/lex.cc"
}
#line 645 "../src/parse/lex.re"

}

void Scanner::lex_code_in_braces()
{
    const loc_t &loc = tok_loc();
    uint32_t depth = 1;
code:

#line 3185 "src/parse/lex.cc"
{
	YYCTYPE yych;
	static const unsigned char yybm[] = {
		  0, 128, 128, 128, 128, 128, 128, 128, 
		128, 160,   0, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		160, 128,   0, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128,   0, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
	};
	if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= '&') {
		if (yych <= '\f') {
			if (yych <= 0x00) goto yy481;
			if (yych == '\n') goto yy485;
			goto yy483;
		} else {
			if (yych <= '\r') goto yy487;
			if (yych == '"') goto yy488;
			goto yy483;
		}
	} else {
		if (yych <= 'z') {
			if (yych <= '\'') goto yy488;
			if (yych == '/') goto yy490;
			goto yy483;
		} else {
			if (yych <= '{') goto yy491;
			if (yych == '}') goto yy493;
			goto yy483;
		}
	}
yy481:
	++YYCURSOR;
#line 665 "../src/parse/lex.re"
	{ fail_if_eof(); goto code; }
#line 3249 "src/parse/lex.cc"
yy483:
	++YYCURSOR;
yy484:
#line 669 "../src/parse/lex.re"
	{ goto code; }
#line 3255 "src/parse/lex.cc"
yy485:
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 32) {
		goto yy495;
	}
	if (yych == '#') goto yy498;
yy486:
#line 664 "../src/parse/lex.re"
	{ next_line(); goto code; }
#line 3265 "src/parse/lex.cc"
yy487:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy485;
	goto yy484;
yy488:
	++YYCURSOR;
#line 668 "../src/parse/lex.re"
	{ lex_string(cur[-1]); goto code; }
#line 3274 "src/parse/lex.cc"
yy490:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '*') goto yy500;
	if (yych == '/') goto yy502;
	goto yy484;
yy491:
	++YYCURSOR;
#line 662 "../src/parse/lex.re"
	{ ++depth; goto code; }
#line 3284 "src/parse/lex.cc"
yy493:
	++YYCURSOR;
#line 654 "../src/parse/lex.re"
	{
        if (--depth == 0) {
            yylval.semact = new SemAct(loc, getstr(tok, cur));
            return;
        }
        goto code;
    }
#line 3295 "src/parse/lex.cc"
yy495:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 32) {
		goto yy495;
	}
	if (yych == '#') goto yy498;
yy497:
	YYCURSOR = YYMARKER;
	goto yy486;
yy498:
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 5) YYFILL(5);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy498;
		goto yy497;
	} else {
		if (yych <= ' ') goto yy498;
		if (yych == 'l') goto yy504;
		goto yy497;
	}
yy500:
	++YYCURSOR;
#line 666 "../src/parse/lex.re"
	{ lex_c_comment(); goto code; }
#line 3323 "src/parse/lex.cc"
yy502:
	++YYCURSOR;
#line 667 "../src/parse/lex.re"
	{ lex_cpp_comment(); goto code; }
#line 3328 "src/parse/lex.cc"
yy504:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych != 'i') goto yy497;
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych != 'n') goto yy497;
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych != 'e') goto yy497;
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '0') goto yy509;
	if (yych <= '9') goto yy497;
	goto yy509;
yy508:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
yy509:
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy508;
		goto yy497;
	} else {
		if (yych <= ' ') goto yy508;
		if (yych <= '0') goto yy497;
		if (yych >= ':') goto yy497;
		yyt1 = YYCURSOR;
	}
yy510:
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 64) {
		goto yy510;
	}
	if (yych <= '\f') {
		if (yych <= 0x08) goto yy497;
		if (yych <= '\t') goto yy512;
		if (yych <= '\n') goto yy514;
		goto yy497;
	} else {
		if (yych <= '\r') goto yy516;
		if (yych != ' ') goto yy497;
	}
yy512:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= 0x1F) {
		if (yych == '\t') goto yy512;
		goto yy497;
	} else {
		if (yych <= ' ') goto yy512;
		if (yych == '"') goto yy517;
		goto yy497;
	}
yy514:
	++YYCURSOR;
	YYCURSOR = yyt1;
#line 663 "../src/parse/lex.re"
	{ set_sourceline (); goto code; }
#line 3387 "src/parse/lex.cc"
yy516:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy514;
	goto yy497;
yy517:
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy517;
	}
	if (yych <= '\n') goto yy497;
	if (yych >= '#') goto yy520;
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy514;
	if (yych == '\r') goto yy516;
	goto yy497;
yy520:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= 0x00) goto yy497;
	if (yych == '\n') goto yy497;
	goto yy517;
}
#line 670 "../src/parse/lex.re"

}

void Scanner::lex_string(char delim)
{
loop:

#line 3421 "src/parse/lex.cc"
{
	YYCTYPE yych;
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= '!') {
		if (yych <= '\n') {
			if (yych <= 0x00) goto yy523;
			if (yych <= '\t') goto yy525;
			goto yy527;
		} else {
			if (yych == '\r') goto yy529;
			goto yy525;
		}
	} else {
		if (yych <= '\'') {
			if (yych <= '"') goto yy530;
			if (yych <= '&') goto yy525;
			goto yy530;
		} else {
			if (yych == '\\') goto yy532;
			goto yy525;
		}
	}
yy523:
	++YYCURSOR;
#line 680 "../src/parse/lex.re"
	{ fail_if_eof(); goto loop; }
#line 3449 "src/parse/lex.cc"
yy525:
	++YYCURSOR;
yy526:
#line 681 "../src/parse/lex.re"
	{ goto loop; }
#line 3455 "src/parse/lex.cc"
yy527:
	++YYCURSOR;
#line 679 "../src/parse/lex.re"
	{ next_line(); goto loop; }
#line 3460 "src/parse/lex.cc"
yy529:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy527;
	goto yy526;
yy530:
	++YYCURSOR;
#line 677 "../src/parse/lex.re"
	{ if (cur[-1] == delim) return; else goto loop; }
#line 3469 "src/parse/lex.cc"
yy532:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '&') {
		if (yych != '"') goto yy526;
	} else {
		if (yych <= '\'') goto yy533;
		if (yych != '\\') goto yy526;
	}
yy533:
	++YYCURSOR;
#line 678 "../src/parse/lex.re"
	{ goto loop; }
#line 3482 "src/parse/lex.cc"
}
#line 682 "../src/parse/lex.re"

}

void Scanner::lex_c_comment()
{
loop:

#line 3492 "src/parse/lex.cc"
{
	YYCTYPE yych;
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= '\f') {
		if (yych <= 0x00) goto yy537;
		if (yych == '\n') goto yy541;
		goto yy539;
	} else {
		if (yych <= '\r') goto yy543;
		if (yych == '*') goto yy544;
		goto yy539;
	}
yy537:
	++YYCURSOR;
#line 691 "../src/parse/lex.re"
	{ fail_if_eof(); goto loop; }
#line 3510 "src/parse/lex.cc"
yy539:
	++YYCURSOR;
yy540:
#line 692 "../src/parse/lex.re"
	{ goto loop; }
#line 3516 "src/parse/lex.cc"
yy541:
	++YYCURSOR;
#line 690 "../src/parse/lex.re"
	{ next_line(); goto loop; }
#line 3521 "src/parse/lex.cc"
yy543:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy541;
	goto yy540;
yy544:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych != '/') goto yy540;
	++YYCURSOR;
#line 689 "../src/parse/lex.re"
	{ return; }
#line 3532 "src/parse/lex.cc"
}
#line 693 "../src/parse/lex.re"

}

void Scanner::lex_cpp_comment()
{
loop:

#line 3542 "src/parse/lex.cc"
{
	YYCTYPE yych;
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= '\n') {
		if (yych <= 0x00) goto yy549;
		if (yych <= '\t') goto yy551;
		goto yy553;
	} else {
		if (yych == '\r') goto yy555;
		goto yy551;
	}
yy549:
	++YYCURSOR;
#line 701 "../src/parse/lex.re"
	{ fail_if_eof(); goto loop; }
#line 3559 "src/parse/lex.cc"
yy551:
	++YYCURSOR;
yy552:
#line 702 "../src/parse/lex.re"
	{ goto loop; }
#line 3565 "src/parse/lex.cc"
yy553:
	++YYCURSOR;
#line 700 "../src/parse/lex.re"
	{ next_line(); return; }
#line 3570 "src/parse/lex.cc"
yy555:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy553;
	goto yy552;
}
#line 703 "../src/parse/lex.re"

}

const AST *Scanner::lex_cls(bool neg)
{
    std::vector<ASTRange> *cls = new std::vector<ASTRange>;
    uint32_t u, l;
    const loc_t &loc0 = tok_loc();
    loc_t loc = cur_loc();
fst:
    tok = cur;

#line 3589 "src/parse/lex.cc"
{
	YYCTYPE yych;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych == ']') goto yy559;
#line 716 "../src/parse/lex.re"
	{ l = lex_cls_chr(); goto snd; }
#line 3597 "src/parse/lex.cc"
yy559:
	++YYCURSOR;
#line 715 "../src/parse/lex.re"
	{ return ast_cls(loc0, cls, neg); }
#line 3602 "src/parse/lex.cc"
}
#line 717 "../src/parse/lex.re"

snd:

#line 3608 "src/parse/lex.cc"
{
	YYCTYPE yych;
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = (YYCTYPE)*(YYMARKER = YYCURSOR);
	if (yych == '-') goto yy564;
yy563:
#line 720 "../src/parse/lex.re"
	{ u = l; goto add; }
#line 3617 "src/parse/lex.cc"
yy564:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych != ']') goto yy566;
	YYCURSOR = YYMARKER;
	goto yy563;
yy566:
	++YYCURSOR;
	YYCURSOR -= 1;
#line 721 "../src/parse/lex.re"
	{
        u = lex_cls_chr();
        if (l > u) {
            msg.warn.swapped_range(loc, l, u);
            std::swap(l, u);
        }
        goto add;
    }
#line 3635 "src/parse/lex.cc"
}
#line 729 "../src/parse/lex.re"

add:
    cls->push_back(ASTRange(l, u, loc));
    loc = cur_loc();
    goto fst;
}

uint32_t Scanner::lex_cls_chr()
{
    tok = cur;
    const loc_t &loc = cur_loc();
    #line 766 "../src/parse/lex.re"

    if (globopts->input_encoding == Enc::ASCII) {
        
#line 3653 "src/parse/lex.cc"
{
	YYCTYPE yych;
	unsigned int yyaccept = 0;
	if ((YYLIMIT - YYCURSOR) < 10) YYFILL(10);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= '\f') {
		if (yych <= 0x00) goto yy570;
		if (yych == '\n') goto yy574;
		goto yy572;
	} else {
		if (yych <= '\r') goto yy576;
		if (yych == '\\') goto yy577;
		goto yy572;
	}
yy570:
	++YYCURSOR;
#line 747 "../src/parse/lex.re"
	{ fail_if_eof(); return 0; }
#line 3672 "src/parse/lex.cc"
yy572:
	++YYCURSOR;
yy573:
#line 749 "../src/parse/lex.re"
	{ return decode(tok); }
#line 3678 "src/parse/lex.cc"
yy574:
	++YYCURSOR;
#line 741 "../src/parse/lex.re"
	{ msg.error(loc, "newline in character class"); exit(1); }
#line 3683 "src/parse/lex.cc"
yy576:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy574;
	goto yy573;
yy577:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '\\') {
		if (yych <= '/') {
			if (yych <= '\f') {
				if (yych <= 0x00) goto yy578;
				if (yych == '\n') goto yy574;
				goto yy579;
			} else {
				if (yych <= '\r') goto yy581;
				if (yych == '-') goto yy582;
				goto yy579;
			}
		} else {
			if (yych <= 'U') {
				if (yych <= '3') goto yy584;
				if (yych <= '7') goto yy586;
				if (yych <= 'T') goto yy579;
				goto yy587;
			} else {
				if (yych == 'X') goto yy589;
				if (yych <= '[') goto yy579;
				goto yy590;
			}
		}
	} else {
		if (yych <= 'n') {
			if (yych <= 'b') {
				if (yych <= ']') goto yy592;
				if (yych <= '`') goto yy579;
				if (yych <= 'a') goto yy594;
				goto yy596;
			} else {
				if (yych == 'f') goto yy598;
				if (yych <= 'm') goto yy579;
				goto yy600;
			}
		} else {
			if (yych <= 't') {
				if (yych == 'r') goto yy602;
				if (yych <= 's') goto yy579;
				goto yy604;
			} else {
				if (yych <= 'v') {
					if (yych <= 'u') goto yy589;
					goto yy606;
				} else {
					if (yych == 'x') goto yy608;
					goto yy579;
				}
			}
		}
	}
yy578:
#line 744 "../src/parse/lex.re"
	{ msg.error(loc, "syntax error in escape sequence"); exit(1); }
#line 3744 "src/parse/lex.cc"
yy579:
	++YYCURSOR;
yy580:
#line 762 "../src/parse/lex.re"
	{
        msg.warn.useless_escape(loc, tok, cur);
        return decode(tok + 1);
    }
#line 3753 "src/parse/lex.cc"
yy581:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy574;
	goto yy580;
yy582:
	++YYCURSOR;
#line 760 "../src/parse/lex.re"
	{ return static_cast<uint8_t>('-'); }
#line 3762 "src/parse/lex.cc"
yy584:
	yyaccept = 0;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= '/') goto yy585;
	if (yych <= '7') goto yy609;
yy585:
#line 743 "../src/parse/lex.re"
	{ msg.error(loc, "syntax error in octal escape sequence"); exit(1); }
#line 3771 "src/parse/lex.cc"
yy586:
	++YYCURSOR;
	goto yy585;
yy587:
	yyaccept = 1;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= '/') goto yy588;
		if (yych <= '9') goto yy611;
	} else {
		if (yych <= 'F') goto yy611;
		if (yych <= '`') goto yy588;
		if (yych <= 'f') goto yy611;
	}
yy588:
#line 742 "../src/parse/lex.re"
	{ msg.error(loc, "syntax error in hexadecimal escape sequence"); exit(1); }
#line 3789 "src/parse/lex.cc"
yy589:
	yyaccept = 1;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= '/') goto yy588;
		if (yych <= '9') goto yy612;
		goto yy588;
	} else {
		if (yych <= 'F') goto yy612;
		if (yych <= '`') goto yy588;
		if (yych <= 'f') goto yy612;
		goto yy588;
	}
yy590:
	++YYCURSOR;
#line 759 "../src/parse/lex.re"
	{ return static_cast<uint8_t>('\\'); }
#line 3807 "src/parse/lex.cc"
yy592:
	++YYCURSOR;
#line 761 "../src/parse/lex.re"
	{ return static_cast<uint8_t>(']'); }
#line 3812 "src/parse/lex.cc"
yy594:
	++YYCURSOR;
#line 752 "../src/parse/lex.re"
	{ return static_cast<uint8_t>('\a'); }
#line 3817 "src/parse/lex.cc"
yy596:
	++YYCURSOR;
#line 753 "../src/parse/lex.re"
	{ return static_cast<uint8_t>('\b'); }
#line 3822 "src/parse/lex.cc"
yy598:
	++YYCURSOR;
#line 754 "../src/parse/lex.re"
	{ return static_cast<uint8_t>('\f'); }
#line 3827 "src/parse/lex.cc"
yy600:
	++YYCURSOR;
#line 755 "../src/parse/lex.re"
	{ return static_cast<uint8_t>('\n'); }
#line 3832 "src/parse/lex.cc"
yy602:
	++YYCURSOR;
#line 756 "../src/parse/lex.re"
	{ return static_cast<uint8_t>('\r'); }
#line 3837 "src/parse/lex.cc"
yy604:
	++YYCURSOR;
#line 757 "../src/parse/lex.re"
	{ return static_cast<uint8_t>('\t'); }
#line 3842 "src/parse/lex.cc"
yy606:
	++YYCURSOR;
#line 758 "../src/parse/lex.re"
	{ return static_cast<uint8_t>('\v'); }
#line 3847 "src/parse/lex.cc"
yy608:
	yyaccept = 1;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= '/') goto yy588;
		if (yych <= '9') goto yy613;
		goto yy588;
	} else {
		if (yych <= 'F') goto yy613;
		if (yych <= '`') goto yy588;
		if (yych <= 'f') goto yy613;
		goto yy588;
	}
yy609:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '/') goto yy610;
	if (yych <= '7') goto yy614;
yy610:
	YYCURSOR = YYMARKER;
	if (yyaccept == 0) {
		goto yy585;
	} else {
		goto yy588;
	}
yy611:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy610;
		if (yych <= '9') goto yy616;
		goto yy610;
	} else {
		if (yych <= 'F') goto yy616;
		if (yych <= '`') goto yy610;
		if (yych <= 'f') goto yy616;
		goto yy610;
	}
yy612:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy610;
		if (yych <= '9') goto yy617;
		goto yy610;
	} else {
		if (yych <= 'F') goto yy617;
		if (yych <= '`') goto yy610;
		if (yych <= 'f') goto yy617;
		goto yy610;
	}
yy613:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy610;
		if (yych <= '9') goto yy618;
		goto yy610;
	} else {
		if (yych <= 'F') goto yy618;
		if (yych <= '`') goto yy610;
		if (yych <= 'f') goto yy618;
		goto yy610;
	}
yy614:
	++YYCURSOR;
#line 751 "../src/parse/lex.re"
	{ return unesc_oct(tok, cur); }
#line 3912 "src/parse/lex.cc"
yy616:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy610;
		if (yych <= '9') goto yy620;
		goto yy610;
	} else {
		if (yych <= 'F') goto yy620;
		if (yych <= '`') goto yy610;
		if (yych <= 'f') goto yy620;
		goto yy610;
	}
yy617:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy610;
		if (yych <= '9') goto yy613;
		goto yy610;
	} else {
		if (yych <= 'F') goto yy613;
		if (yych <= '`') goto yy610;
		if (yych <= 'f') goto yy613;
		goto yy610;
	}
yy618:
	++YYCURSOR;
#line 750 "../src/parse/lex.re"
	{ return unesc_hex(tok, cur); }
#line 3941 "src/parse/lex.cc"
yy620:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy610;
		if (yych >= ':') goto yy610;
	} else {
		if (yych <= 'F') goto yy621;
		if (yych <= '`') goto yy610;
		if (yych >= 'g') goto yy610;
	}
yy621:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy610;
		if (yych <= '9') goto yy612;
		goto yy610;
	} else {
		if (yych <= 'F') goto yy612;
		if (yych <= '`') goto yy610;
		if (yych <= 'f') goto yy612;
		goto yy610;
	}
}
#line 768 "../src/parse/lex.re"

    }
    else {
        
#line 3970 "src/parse/lex.cc"
{
	YYCTYPE yych;
	unsigned int yyaccept = 0;
	if ((YYLIMIT - YYCURSOR) < 10) YYFILL(10);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= 0x7F) {
		if (yych <= '\f') {
			if (yych <= 0x00) goto yy624;
			if (yych == '\n') goto yy628;
			goto yy626;
		} else {
			if (yych <= '\r') goto yy630;
			if (yych == '\\') goto yy631;
			goto yy626;
		}
	} else {
		if (yych <= 0xEF) {
			if (yych <= 0xC1) goto yy633;
			if (yych <= 0xDF) goto yy635;
			if (yych <= 0xE0) goto yy636;
			goto yy637;
		} else {
			if (yych <= 0xF0) goto yy638;
			if (yych <= 0xF3) goto yy639;
			if (yych <= 0xF4) goto yy640;
			goto yy633;
		}
	}
yy624:
	++YYCURSOR;
#line 747 "../src/parse/lex.re"
	{ fail_if_eof(); return 0; }
#line 4003 "src/parse/lex.cc"
yy626:
	++YYCURSOR;
yy627:
#line 749 "../src/parse/lex.re"
	{ return decode(tok); }
#line 4009 "src/parse/lex.cc"
yy628:
	++YYCURSOR;
#line 741 "../src/parse/lex.re"
	{ msg.error(loc, "newline in character class"); exit(1); }
#line 4014 "src/parse/lex.cc"
yy630:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy628;
	goto yy627;
yy631:
	yyaccept = 0;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= 'b') {
		if (yych <= '7') {
			if (yych <= '\r') {
				if (yych <= '\t') {
					if (yych >= 0x01) goto yy641;
				} else {
					if (yych <= '\n') goto yy628;
					if (yych <= '\f') goto yy641;
					goto yy643;
				}
			} else {
				if (yych <= '-') {
					if (yych <= ',') goto yy641;
					goto yy644;
				} else {
					if (yych <= '/') goto yy641;
					if (yych <= '3') goto yy646;
					goto yy648;
				}
			}
		} else {
			if (yych <= '[') {
				if (yych <= 'U') {
					if (yych <= 'T') goto yy641;
					goto yy649;
				} else {
					if (yych == 'X') goto yy651;
					goto yy641;
				}
			} else {
				if (yych <= ']') {
					if (yych <= '\\') goto yy652;
					goto yy654;
				} else {
					if (yych <= '`') goto yy641;
					if (yych <= 'a') goto yy656;
					goto yy658;
				}
			}
		}
	} else {
		if (yych <= 'v') {
			if (yych <= 'q') {
				if (yych <= 'f') {
					if (yych <= 'e') goto yy641;
					goto yy660;
				} else {
					if (yych == 'n') goto yy662;
					goto yy641;
				}
			} else {
				if (yych <= 's') {
					if (yych <= 'r') goto yy664;
					goto yy641;
				} else {
					if (yych <= 't') goto yy666;
					if (yych <= 'u') goto yy651;
					goto yy668;
				}
			}
		} else {
			if (yych <= 0xDF) {
				if (yych <= 'x') {
					if (yych <= 'w') goto yy641;
					goto yy670;
				} else {
					if (yych <= 0x7F) goto yy641;
					if (yych >= 0xC2) goto yy671;
				}
			} else {
				if (yych <= 0xF0) {
					if (yych <= 0xE0) goto yy673;
					if (yych <= 0xEF) goto yy674;
					goto yy675;
				} else {
					if (yych <= 0xF3) goto yy676;
					if (yych <= 0xF4) goto yy677;
				}
			}
		}
	}
yy632:
#line 744 "../src/parse/lex.re"
	{ msg.error(loc, "syntax error in escape sequence"); exit(1); }
#line 4106 "src/parse/lex.cc"
yy633:
	++YYCURSOR;
yy634:
#line 745 "../src/parse/lex.re"
	{ msg.error(loc, "syntax error"); exit(1); }
#line 4112 "src/parse/lex.cc"
yy635:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= 0x7F) goto yy634;
	if (yych <= 0xBF) goto yy626;
	goto yy634;
yy636:
	yyaccept = 1;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= 0x9F) goto yy634;
	if (yych <= 0xBF) goto yy678;
	goto yy634;
yy637:
	yyaccept = 1;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= 0x7F) goto yy634;
	if (yych <= 0xBF) goto yy678;
	goto yy634;
yy638:
	yyaccept = 1;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= 0x8F) goto yy634;
	if (yych <= 0xBF) goto yy679;
	goto yy634;
yy639:
	yyaccept = 1;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= 0x7F) goto yy634;
	if (yych <= 0xBF) goto yy679;
	goto yy634;
yy640:
	yyaccept = 1;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= 0x7F) goto yy634;
	if (yych <= 0x8F) goto yy679;
	goto yy634;
yy641:
	++YYCURSOR;
yy642:
#line 762 "../src/parse/lex.re"
	{
        msg.warn.useless_escape(loc, tok, cur);
        return decode(tok + 1);
    }
#line 4156 "src/parse/lex.cc"
yy643:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy628;
	goto yy642;
yy644:
	++YYCURSOR;
#line 760 "../src/parse/lex.re"
	{ return static_cast<uint8_t>('-'); }
#line 4165 "src/parse/lex.cc"
yy646:
	yyaccept = 2;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= '/') goto yy647;
	if (yych <= '7') goto yy680;
yy647:
#line 743 "../src/parse/lex.re"
	{ msg.error(loc, "syntax error in octal escape sequence"); exit(1); }
#line 4174 "src/parse/lex.cc"
yy648:
	++YYCURSOR;
	goto yy647;
yy649:
	yyaccept = 3;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= '/') goto yy650;
		if (yych <= '9') goto yy681;
	} else {
		if (yych <= 'F') goto yy681;
		if (yych <= '`') goto yy650;
		if (yych <= 'f') goto yy681;
	}
yy650:
#line 742 "../src/parse/lex.re"
	{ msg.error(loc, "syntax error in hexadecimal escape sequence"); exit(1); }
#line 4192 "src/parse/lex.cc"
yy651:
	yyaccept = 3;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= '/') goto yy650;
		if (yych <= '9') goto yy682;
		goto yy650;
	} else {
		if (yych <= 'F') goto yy682;
		if (yych <= '`') goto yy650;
		if (yych <= 'f') goto yy682;
		goto yy650;
	}
yy652:
	++YYCURSOR;
#line 759 "../src/parse/lex.re"
	{ return static_cast<uint8_t>('\\'); }
#line 4210 "src/parse/lex.cc"
yy654:
	++YYCURSOR;
#line 761 "../src/parse/lex.re"
	{ return static_cast<uint8_t>(']'); }
#line 4215 "src/parse/lex.cc"
yy656:
	++YYCURSOR;
#line 752 "../src/parse/lex.re"
	{ return static_cast<uint8_t>('\a'); }
#line 4220 "src/parse/lex.cc"
yy658:
	++YYCURSOR;
#line 753 "../src/parse/lex.re"
	{ return static_cast<uint8_t>('\b'); }
#line 4225 "src/parse/lex.cc"
yy660:
	++YYCURSOR;
#line 754 "../src/parse/lex.re"
	{ return static_cast<uint8_t>('\f'); }
#line 4230 "src/parse/lex.cc"
yy662:
	++YYCURSOR;
#line 755 "../src/parse/lex.re"
	{ return static_cast<uint8_t>('\n'); }
#line 4235 "src/parse/lex.cc"
yy664:
	++YYCURSOR;
#line 756 "../src/parse/lex.re"
	{ return static_cast<uint8_t>('\r'); }
#line 4240 "src/parse/lex.cc"
yy666:
	++YYCURSOR;
#line 757 "../src/parse/lex.re"
	{ return static_cast<uint8_t>('\t'); }
#line 4245 "src/parse/lex.cc"
yy668:
	++YYCURSOR;
#line 758 "../src/parse/lex.re"
	{ return static_cast<uint8_t>('\v'); }
#line 4250 "src/parse/lex.cc"
yy670:
	yyaccept = 3;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= '/') goto yy650;
		if (yych <= '9') goto yy683;
		goto yy650;
	} else {
		if (yych <= 'F') goto yy683;
		if (yych <= '`') goto yy650;
		if (yych <= 'f') goto yy683;
		goto yy650;
	}
yy671:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= 0x7F) goto yy672;
	if (yych <= 0xBF) goto yy641;
yy672:
	YYCURSOR = YYMARKER;
	if (yyaccept <= 1) {
		if (yyaccept == 0) {
			goto yy632;
		} else {
			goto yy634;
		}
	} else {
		if (yyaccept == 2) {
			goto yy647;
		} else {
			goto yy650;
		}
	}
yy673:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= 0x9F) goto yy672;
	if (yych <= 0xBF) goto yy671;
	goto yy672;
yy674:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= 0x7F) goto yy672;
	if (yych <= 0xBF) goto yy671;
	goto yy672;
yy675:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= 0x8F) goto yy672;
	if (yych <= 0xBF) goto yy674;
	goto yy672;
yy676:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= 0x7F) goto yy672;
	if (yych <= 0xBF) goto yy674;
	goto yy672;
yy677:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= 0x7F) goto yy672;
	if (yych <= 0x8F) goto yy674;
	goto yy672;
yy678:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= 0x7F) goto yy672;
	if (yych <= 0xBF) goto yy626;
	goto yy672;
yy679:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= 0x7F) goto yy672;
	if (yych <= 0xBF) goto yy678;
	goto yy672;
yy680:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '/') goto yy672;
	if (yych <= '7') goto yy684;
	goto yy672;
yy681:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy672;
		if (yych <= '9') goto yy686;
		goto yy672;
	} else {
		if (yych <= 'F') goto yy686;
		if (yych <= '`') goto yy672;
		if (yych <= 'f') goto yy686;
		goto yy672;
	}
yy682:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy672;
		if (yych <= '9') goto yy687;
		goto yy672;
	} else {
		if (yych <= 'F') goto yy687;
		if (yych <= '`') goto yy672;
		if (yych <= 'f') goto yy687;
		goto yy672;
	}
yy683:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy672;
		if (yych <= '9') goto yy688;
		goto yy672;
	} else {
		if (yych <= 'F') goto yy688;
		if (yych <= '`') goto yy672;
		if (yych <= 'f') goto yy688;
		goto yy672;
	}
yy684:
	++YYCURSOR;
#line 751 "../src/parse/lex.re"
	{ return unesc_oct(tok, cur); }
#line 4363 "src/parse/lex.cc"
yy686:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy672;
		if (yych <= '9') goto yy690;
		goto yy672;
	} else {
		if (yych <= 'F') goto yy690;
		if (yych <= '`') goto yy672;
		if (yych <= 'f') goto yy690;
		goto yy672;
	}
yy687:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy672;
		if (yych <= '9') goto yy683;
		goto yy672;
	} else {
		if (yych <= 'F') goto yy683;
		if (yych <= '`') goto yy672;
		if (yych <= 'f') goto yy683;
		goto yy672;
	}
yy688:
	++YYCURSOR;
#line 750 "../src/parse/lex.re"
	{ return unesc_hex(tok, cur); }
#line 4392 "src/parse/lex.cc"
yy690:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy672;
		if (yych >= ':') goto yy672;
	} else {
		if (yych <= 'F') goto yy691;
		if (yych <= '`') goto yy672;
		if (yych >= 'g') goto yy672;
	}
yy691:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy672;
		if (yych <= '9') goto yy682;
		goto yy672;
	} else {
		if (yych <= 'F') goto yy682;
		if (yych <= '`') goto yy672;
		if (yych <= 'f') goto yy682;
		goto yy672;
	}
}
#line 771 "../src/parse/lex.re"
 #line 771 "../src/parse/lex.re"

    }
}

bool Scanner::lex_str_chr(char quote, ASTChar &ast)
{
    tok = cur;
    ast.loc = cur_loc();

    #line 805 "../src/parse/lex.re"

    if (globopts->input_encoding == Enc::ASCII) {
        
#line 4431 "src/parse/lex.cc"
{
	YYCTYPE yych;
	unsigned int yyaccept = 0;
	if ((YYLIMIT - YYCURSOR) < 10) YYFILL(10);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= '\f') {
		if (yych <= 0x00) goto yy694;
		if (yych == '\n') goto yy698;
		goto yy696;
	} else {
		if (yych <= '\r') goto yy700;
		if (yych == '\\') goto yy701;
		goto yy696;
	}
yy694:
	++YYCURSOR;
#line 787 "../src/parse/lex.re"
	{ fail_if_eof(); ast.chr = 0; return true; }
#line 4450 "src/parse/lex.cc"
yy696:
	++YYCURSOR;
yy697:
#line 789 "../src/parse/lex.re"
	{ ast.chr = decode(tok); return tok[0] != quote; }
#line 4456 "src/parse/lex.cc"
yy698:
	++YYCURSOR;
#line 781 "../src/parse/lex.re"
	{ msg.error(ast.loc, "newline in character string"); exit(1); }
#line 4461 "src/parse/lex.cc"
yy700:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy698;
	goto yy697;
yy701:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '`') {
		if (yych <= '3') {
			if (yych <= '\n') {
				if (yych <= 0x00) goto yy702;
				if (yych <= '\t') goto yy703;
				goto yy698;
			} else {
				if (yych == '\r') goto yy705;
				if (yych <= '/') goto yy703;
				goto yy706;
			}
		} else {
			if (yych <= 'W') {
				if (yych <= '7') goto yy708;
				if (yych == 'U') goto yy709;
				goto yy703;
			} else {
				if (yych <= 'X') goto yy711;
				if (yych == '\\') goto yy712;
				goto yy703;
			}
		}
	} else {
		if (yych <= 'q') {
			if (yych <= 'e') {
				if (yych <= 'a') goto yy714;
				if (yych <= 'b') goto yy716;
				goto yy703;
			} else {
				if (yych <= 'f') goto yy718;
				if (yych == 'n') goto yy720;
				goto yy703;
			}
		} else {
			if (yych <= 'u') {
				if (yych <= 'r') goto yy722;
				if (yych <= 's') goto yy703;
				if (yych <= 't') goto yy724;
				goto yy711;
			} else {
				if (yych <= 'v') goto yy726;
				if (yych == 'x') goto yy728;
				goto yy703;
			}
		}
	}
yy702:
#line 784 "../src/parse/lex.re"
	{ msg.error(ast.loc, "syntax error in escape sequence"); exit(1); }
#line 4517 "src/parse/lex.cc"
yy703:
	++YYCURSOR;
yy704:
#line 800 "../src/parse/lex.re"
	{
        ast.chr = decode(tok + 1);
        if (tok[1] != quote) msg.warn.useless_escape(ast.loc, tok, cur);
        return true;
    }
#line 4527 "src/parse/lex.cc"
yy705:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy698;
	goto yy704;
yy706:
	yyaccept = 0;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= '/') goto yy707;
	if (yych <= '7') goto yy729;
yy707:
#line 783 "../src/parse/lex.re"
	{ msg.error(ast.loc, "syntax error in octal escape sequence"); exit(1); }
#line 4540 "src/parse/lex.cc"
yy708:
	++YYCURSOR;
	goto yy707;
yy709:
	yyaccept = 1;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= '/') goto yy710;
		if (yych <= '9') goto yy731;
	} else {
		if (yych <= 'F') goto yy731;
		if (yych <= '`') goto yy710;
		if (yych <= 'f') goto yy731;
	}
yy710:
#line 782 "../src/parse/lex.re"
	{ msg.error(ast.loc, "syntax error in hexadecimal escape sequence"); exit(1); }
#line 4558 "src/parse/lex.cc"
yy711:
	yyaccept = 1;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= '/') goto yy710;
		if (yych <= '9') goto yy732;
		goto yy710;
	} else {
		if (yych <= 'F') goto yy732;
		if (yych <= '`') goto yy710;
		if (yych <= 'f') goto yy732;
		goto yy710;
	}
yy712:
	++YYCURSOR;
#line 799 "../src/parse/lex.re"
	{ ast.chr = static_cast<uint8_t>('\\'); return true; }
#line 4576 "src/parse/lex.cc"
yy714:
	++YYCURSOR;
#line 792 "../src/parse/lex.re"
	{ ast.chr = static_cast<uint8_t>('\a'); return true; }
#line 4581 "src/parse/lex.cc"
yy716:
	++YYCURSOR;
#line 793 "../src/parse/lex.re"
	{ ast.chr = static_cast<uint8_t>('\b'); return true; }
#line 4586 "src/parse/lex.cc"
yy718:
	++YYCURSOR;
#line 794 "../src/parse/lex.re"
	{ ast.chr = static_cast<uint8_t>('\f'); return true; }
#line 4591 "src/parse/lex.cc"
yy720:
	++YYCURSOR;
#line 795 "../src/parse/lex.re"
	{ ast.chr = static_cast<uint8_t>('\n'); return true; }
#line 4596 "src/parse/lex.cc"
yy722:
	++YYCURSOR;
#line 796 "../src/parse/lex.re"
	{ ast.chr = static_cast<uint8_t>('\r'); return true; }
#line 4601 "src/parse/lex.cc"
yy724:
	++YYCURSOR;
#line 797 "../src/parse/lex.re"
	{ ast.chr = static_cast<uint8_t>('\t'); return true; }
#line 4606 "src/parse/lex.cc"
yy726:
	++YYCURSOR;
#line 798 "../src/parse/lex.re"
	{ ast.chr = static_cast<uint8_t>('\v'); return true; }
#line 4611 "src/parse/lex.cc"
yy728:
	yyaccept = 1;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= '/') goto yy710;
		if (yych <= '9') goto yy733;
		goto yy710;
	} else {
		if (yych <= 'F') goto yy733;
		if (yych <= '`') goto yy710;
		if (yych <= 'f') goto yy733;
		goto yy710;
	}
yy729:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '/') goto yy730;
	if (yych <= '7') goto yy734;
yy730:
	YYCURSOR = YYMARKER;
	if (yyaccept == 0) {
		goto yy707;
	} else {
		goto yy710;
	}
yy731:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy730;
		if (yych <= '9') goto yy736;
		goto yy730;
	} else {
		if (yych <= 'F') goto yy736;
		if (yych <= '`') goto yy730;
		if (yych <= 'f') goto yy736;
		goto yy730;
	}
yy732:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy730;
		if (yych <= '9') goto yy737;
		goto yy730;
	} else {
		if (yych <= 'F') goto yy737;
		if (yych <= '`') goto yy730;
		if (yych <= 'f') goto yy737;
		goto yy730;
	}
yy733:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy730;
		if (yych <= '9') goto yy738;
		goto yy730;
	} else {
		if (yych <= 'F') goto yy738;
		if (yych <= '`') goto yy730;
		if (yych <= 'f') goto yy738;
		goto yy730;
	}
yy734:
	++YYCURSOR;
#line 791 "../src/parse/lex.re"
	{ ast.chr = unesc_oct(tok, cur); return true; }
#line 4676 "src/parse/lex.cc"
yy736:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy730;
		if (yych <= '9') goto yy740;
		goto yy730;
	} else {
		if (yych <= 'F') goto yy740;
		if (yych <= '`') goto yy730;
		if (yych <= 'f') goto yy740;
		goto yy730;
	}
yy737:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy730;
		if (yych <= '9') goto yy733;
		goto yy730;
	} else {
		if (yych <= 'F') goto yy733;
		if (yych <= '`') goto yy730;
		if (yych <= 'f') goto yy733;
		goto yy730;
	}
yy738:
	++YYCURSOR;
#line 790 "../src/parse/lex.re"
	{ ast.chr = unesc_hex(tok, cur); return true; }
#line 4705 "src/parse/lex.cc"
yy740:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy730;
		if (yych >= ':') goto yy730;
	} else {
		if (yych <= 'F') goto yy741;
		if (yych <= '`') goto yy730;
		if (yych >= 'g') goto yy730;
	}
yy741:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy730;
		if (yych <= '9') goto yy732;
		goto yy730;
	} else {
		if (yych <= 'F') goto yy732;
		if (yych <= '`') goto yy730;
		if (yych <= 'f') goto yy732;
		goto yy730;
	}
}
#line 807 "../src/parse/lex.re"

    }
    else {
        
#line 4734 "src/parse/lex.cc"
{
	YYCTYPE yych;
	unsigned int yyaccept = 0;
	if ((YYLIMIT - YYCURSOR) < 10) YYFILL(10);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= 0x7F) {
		if (yych <= '\f') {
			if (yych <= 0x00) goto yy744;
			if (yych == '\n') goto yy748;
			goto yy746;
		} else {
			if (yych <= '\r') goto yy750;
			if (yych == '\\') goto yy751;
			goto yy746;
		}
	} else {
		if (yych <= 0xEF) {
			if (yych <= 0xC1) goto yy753;
			if (yych <= 0xDF) goto yy755;
			if (yych <= 0xE0) goto yy756;
			goto yy757;
		} else {
			if (yych <= 0xF0) goto yy758;
			if (yych <= 0xF3) goto yy759;
			if (yych <= 0xF4) goto yy760;
			goto yy753;
		}
	}
yy744:
	++YYCURSOR;
#line 787 "../src/parse/lex.re"
	{ fail_if_eof(); ast.chr = 0; return true; }
#line 4767 "src/parse/lex.cc"
yy746:
	++YYCURSOR;
yy747:
#line 789 "../src/parse/lex.re"
	{ ast.chr = decode(tok); return tok[0] != quote; }
#line 4773 "src/parse/lex.cc"
yy748:
	++YYCURSOR;
#line 781 "../src/parse/lex.re"
	{ msg.error(ast.loc, "newline in character string"); exit(1); }
#line 4778 "src/parse/lex.cc"
yy750:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy748;
	goto yy747;
yy751:
	yyaccept = 0;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= 'f') {
		if (yych <= 'T') {
			if (yych <= '\f') {
				if (yych <= 0x00) goto yy752;
				if (yych == '\n') goto yy748;
				goto yy761;
			} else {
				if (yych <= '/') {
					if (yych <= '\r') goto yy763;
					goto yy761;
				} else {
					if (yych <= '3') goto yy764;
					if (yych <= '7') goto yy766;
					goto yy761;
				}
			}
		} else {
			if (yych <= '\\') {
				if (yych <= 'W') {
					if (yych <= 'U') goto yy767;
					goto yy761;
				} else {
					if (yych <= 'X') goto yy769;
					if (yych <= '[') goto yy761;
					goto yy770;
				}
			} else {
				if (yych <= 'a') {
					if (yych <= '`') goto yy761;
					goto yy772;
				} else {
					if (yych <= 'b') goto yy774;
					if (yych <= 'e') goto yy761;
					goto yy776;
				}
			}
		}
	} else {
		if (yych <= 'w') {
			if (yych <= 'r') {
				if (yych == 'n') goto yy778;
				if (yych <= 'q') goto yy761;
				goto yy780;
			} else {
				if (yych <= 't') {
					if (yych <= 's') goto yy761;
					goto yy782;
				} else {
					if (yych <= 'u') goto yy769;
					if (yych <= 'v') goto yy784;
					goto yy761;
				}
			}
		} else {
			if (yych <= 0xE0) {
				if (yych <= 0x7F) {
					if (yych <= 'x') goto yy786;
					goto yy761;
				} else {
					if (yych <= 0xC1) goto yy752;
					if (yych <= 0xDF) goto yy787;
					goto yy789;
				}
			} else {
				if (yych <= 0xF0) {
					if (yych <= 0xEF) goto yy790;
					goto yy791;
				} else {
					if (yych <= 0xF3) goto yy792;
					if (yych <= 0xF4) goto yy793;
				}
			}
		}
	}
yy752:
#line 784 "../src/parse/lex.re"
	{ msg.error(ast.loc, "syntax error in escape sequence"); exit(1); }
#line 4863 "src/parse/lex.cc"
yy753:
	++YYCURSOR;
yy754:
#line 785 "../src/parse/lex.re"
	{ msg.error(ast.loc, "syntax error"); exit(1); }
#line 4869 "src/parse/lex.cc"
yy755:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= 0x7F) goto yy754;
	if (yych <= 0xBF) goto yy746;
	goto yy754;
yy756:
	yyaccept = 1;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= 0x9F) goto yy754;
	if (yych <= 0xBF) goto yy794;
	goto yy754;
yy757:
	yyaccept = 1;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= 0x7F) goto yy754;
	if (yych <= 0xBF) goto yy794;
	goto yy754;
yy758:
	yyaccept = 1;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= 0x8F) goto yy754;
	if (yych <= 0xBF) goto yy795;
	goto yy754;
yy759:
	yyaccept = 1;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= 0x7F) goto yy754;
	if (yych <= 0xBF) goto yy795;
	goto yy754;
yy760:
	yyaccept = 1;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= 0x7F) goto yy754;
	if (yych <= 0x8F) goto yy795;
	goto yy754;
yy761:
	++YYCURSOR;
yy762:
#line 800 "../src/parse/lex.re"
	{
        ast.chr = decode(tok + 1);
        if (tok[1] != quote) msg.warn.useless_escape(ast.loc, tok, cur);
        return true;
    }
#line 4914 "src/parse/lex.cc"
yy763:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy748;
	goto yy762;
yy764:
	yyaccept = 2;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= '/') goto yy765;
	if (yych <= '7') goto yy796;
yy765:
#line 783 "../src/parse/lex.re"
	{ msg.error(ast.loc, "syntax error in octal escape sequence"); exit(1); }
#line 4927 "src/parse/lex.cc"
yy766:
	++YYCURSOR;
	goto yy765;
yy767:
	yyaccept = 3;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= '/') goto yy768;
		if (yych <= '9') goto yy797;
	} else {
		if (yych <= 'F') goto yy797;
		if (yych <= '`') goto yy768;
		if (yych <= 'f') goto yy797;
	}
yy768:
#line 782 "../src/parse/lex.re"
	{ msg.error(ast.loc, "syntax error in hexadecimal escape sequence"); exit(1); }
#line 4945 "src/parse/lex.cc"
yy769:
	yyaccept = 3;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= '/') goto yy768;
		if (yych <= '9') goto yy798;
		goto yy768;
	} else {
		if (yych <= 'F') goto yy798;
		if (yych <= '`') goto yy768;
		if (yych <= 'f') goto yy798;
		goto yy768;
	}
yy770:
	++YYCURSOR;
#line 799 "../src/parse/lex.re"
	{ ast.chr = static_cast<uint8_t>('\\'); return true; }
#line 4963 "src/parse/lex.cc"
yy772:
	++YYCURSOR;
#line 792 "../src/parse/lex.re"
	{ ast.chr = static_cast<uint8_t>('\a'); return true; }
#line 4968 "src/parse/lex.cc"
yy774:
	++YYCURSOR;
#line 793 "../src/parse/lex.re"
	{ ast.chr = static_cast<uint8_t>('\b'); return true; }
#line 4973 "src/parse/lex.cc"
yy776:
	++YYCURSOR;
#line 794 "../src/parse/lex.re"
	{ ast.chr = static_cast<uint8_t>('\f'); return true; }
#line 4978 "src/parse/lex.cc"
yy778:
	++YYCURSOR;
#line 795 "../src/parse/lex.re"
	{ ast.chr = static_cast<uint8_t>('\n'); return true; }
#line 4983 "src/parse/lex.cc"
yy780:
	++YYCURSOR;
#line 796 "../src/parse/lex.re"
	{ ast.chr = static_cast<uint8_t>('\r'); return true; }
#line 4988 "src/parse/lex.cc"
yy782:
	++YYCURSOR;
#line 797 "../src/parse/lex.re"
	{ ast.chr = static_cast<uint8_t>('\t'); return true; }
#line 4993 "src/parse/lex.cc"
yy784:
	++YYCURSOR;
#line 798 "../src/parse/lex.re"
	{ ast.chr = static_cast<uint8_t>('\v'); return true; }
#line 4998 "src/parse/lex.cc"
yy786:
	yyaccept = 3;
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= '/') goto yy768;
		if (yych <= '9') goto yy799;
		goto yy768;
	} else {
		if (yych <= 'F') goto yy799;
		if (yych <= '`') goto yy768;
		if (yych <= 'f') goto yy799;
		goto yy768;
	}
yy787:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= 0x7F) goto yy788;
	if (yych <= 0xBF) goto yy761;
yy788:
	YYCURSOR = YYMARKER;
	if (yyaccept <= 1) {
		if (yyaccept == 0) {
			goto yy752;
		} else {
			goto yy754;
		}
	} else {
		if (yyaccept == 2) {
			goto yy765;
		} else {
			goto yy768;
		}
	}
yy789:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= 0x9F) goto yy788;
	if (yych <= 0xBF) goto yy787;
	goto yy788;
yy790:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= 0x7F) goto yy788;
	if (yych <= 0xBF) goto yy787;
	goto yy788;
yy791:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= 0x8F) goto yy788;
	if (yych <= 0xBF) goto yy790;
	goto yy788;
yy792:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= 0x7F) goto yy788;
	if (yych <= 0xBF) goto yy790;
	goto yy788;
yy793:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= 0x7F) goto yy788;
	if (yych <= 0x8F) goto yy790;
	goto yy788;
yy794:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= 0x7F) goto yy788;
	if (yych <= 0xBF) goto yy746;
	goto yy788;
yy795:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= 0x7F) goto yy788;
	if (yych <= 0xBF) goto yy794;
	goto yy788;
yy796:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '/') goto yy788;
	if (yych <= '7') goto yy800;
	goto yy788;
yy797:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy788;
		if (yych <= '9') goto yy802;
		goto yy788;
	} else {
		if (yych <= 'F') goto yy802;
		if (yych <= '`') goto yy788;
		if (yych <= 'f') goto yy802;
		goto yy788;
	}
yy798:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy788;
		if (yych <= '9') goto yy803;
		goto yy788;
	} else {
		if (yych <= 'F') goto yy803;
		if (yych <= '`') goto yy788;
		if (yych <= 'f') goto yy803;
		goto yy788;
	}
yy799:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy788;
		if (yych <= '9') goto yy804;
		goto yy788;
	} else {
		if (yych <= 'F') goto yy804;
		if (yych <= '`') goto yy788;
		if (yych <= 'f') goto yy804;
		goto yy788;
	}
yy800:
	++YYCURSOR;
#line 791 "../src/parse/lex.re"
	{ ast.chr = unesc_oct(tok, cur); return true; }
#line 5111 "src/parse/lex.cc"
yy802:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy788;
		if (yych <= '9') goto yy806;
		goto yy788;
	} else {
		if (yych <= 'F') goto yy806;
		if (yych <= '`') goto yy788;
		if (yych <= 'f') goto yy806;
		goto yy788;
	}
yy803:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy788;
		if (yych <= '9') goto yy799;
		goto yy788;
	} else {
		if (yych <= 'F') goto yy799;
		if (yych <= '`') goto yy788;
		if (yych <= 'f') goto yy799;
		goto yy788;
	}
yy804:
	++YYCURSOR;
#line 790 "../src/parse/lex.re"
	{ ast.chr = unesc_hex(tok, cur); return true; }
#line 5140 "src/parse/lex.cc"
yy806:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy788;
		if (yych >= ':') goto yy788;
	} else {
		if (yych <= 'F') goto yy807;
		if (yych <= '`') goto yy788;
		if (yych >= 'g') goto yy788;
	}
yy807:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy788;
		if (yych <= '9') goto yy798;
		goto yy788;
	} else {
		if (yych <= 'F') goto yy798;
		if (yych <= '`') goto yy788;
		if (yych <= 'f') goto yy798;
		goto yy788;
	}
}
#line 810 "../src/parse/lex.re"
 #line 810 "../src/parse/lex.re"

    }
}

const AST *Scanner::lex_str(char quote)
{
    const loc_t &loc = tok_loc();
    std::vector<ASTChar> *str = new std::vector<ASTChar>;
    ASTChar c;
    for (;;) {
        if (!lex_str_chr(quote, c)) {
            return ast_str(loc, str, quote == '\'');
        }
        str->push_back(c);
    }
}

void Scanner::set_sourceline ()
{
sourceline:
    tok = cur;

#line 5188 "src/parse/lex.cc"
{
	YYCTYPE yych;
	static const unsigned char yybm[] = {
		  0, 128, 128, 128, 128, 128, 128, 128, 
		128, 128,   0, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128,   0, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128,   0, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
	};
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= '\r') {
		if (yych <= '\t') {
			if (yych >= 0x01) goto yy812;
		} else {
			if (yych <= '\n') goto yy814;
			if (yych <= '\f') goto yy812;
			goto yy816;
		}
	} else {
		if (yych <= '"') {
			if (yych <= '!') goto yy812;
			goto yy817;
		} else {
			if (yych <= '0') goto yy812;
			if (yych <= '9') goto yy818;
			goto yy812;
		}
	}
	++YYCURSOR;
#line 852 "../src/parse/lex.re"
	{ --cur; return; }
#line 5248 "src/parse/lex.cc"
yy812:
	++YYCURSOR;
yy813:
#line 853 "../src/parse/lex.re"
	{ goto sourceline; }
#line 5254 "src/parse/lex.cc"
yy814:
	++YYCURSOR;
#line 851 "../src/parse/lex.re"
	{ pos = tok = cur; return; }
#line 5259 "src/parse/lex.cc"
yy816:
	yych = (YYCTYPE)*++YYCURSOR;
	if (yych == '\n') goto yy814;
	goto yy813;
yy817:
	yych = (YYCTYPE)*(YYMARKER = ++YYCURSOR);
	if (yych <= 0x00) goto yy813;
	if (yych == '\n') goto yy813;
	goto yy822;
yy818:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yybm[0+yych] & 64) {
		goto yy818;
	}
#line 832 "../src/parse/lex.re"
	{
        uint32_t l;
        if (!s_to_u32_unsafe(tok, cur, l)) {
            msg.error(tok_loc(), "line number overflow");
            exit(1);
        }
        set_line(l);
        goto sourceline;
    }
#line 5286 "src/parse/lex.cc"
yy821:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
yy822:
	if (yybm[0+yych] & 128) {
		goto yy821;
	}
	if (yych <= '\n') goto yy823;
	if (yych <= '"') goto yy824;
	goto yy826;
yy823:
	YYCURSOR = YYMARKER;
	goto yy813;
yy824:
	++YYCURSOR;
#line 842 "../src/parse/lex.re"
	{
        Input &in = get_input();
        std::string &name = in.escaped_name;
        name = escape_backslashes(getstr(tok + 1, cur - 1));
        in.fidx = static_cast<uint32_t>(msg.filenames.size());
        msg.filenames.push_back(name);
        goto sourceline;
    }
#line 5312 "src/parse/lex.cc"
yy826:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = (YYCTYPE)*YYCURSOR;
	if (yych <= 0x00) goto yy823;
	if (yych == '\n') goto yy823;
	goto yy821;
}
#line 854 "../src/parse/lex.re"

}

void Scanner::fail_if_eof() const
{
    if (is_eof()) {
        msg.error(cur_loc(), "unexpected end of input");
        exit(1);
    }
}

#undef YYCTYPE
#undef YYCURSOR
#undef YYLIMIT
#undef YYMARKER
#undef YYFILL

} // end namespace re2c
