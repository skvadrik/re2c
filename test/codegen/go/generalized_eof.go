// Code generated by re2go, DO NOT EDIT.
//go:generate re2go $INPUT -o $OUTPUT --api simple -i
package main

import "strings"



func lex_simple(yyinput string) int {
	yycursor := 0
	yymarker := 0
	yylimit := len(yyinput)

	
{
	var yych byte
	if (yylimit <= yycursor) {
		goto yy8
	}
	yych = yyinput[yycursor]
	switch (yych) {
	case 'a':
		goto yy3
	case 'b':
		goto yy4
	case 'c':
		goto yy5
	default:
		goto yy1
	}
yy1:
	yycursor += 1
yy2:
	{ return 1 }
yy3:
	yycursor += 1
	if (yylimit <= yycursor) {
		goto yy9
	}
	{ return 3 }
yy4:
	yycursor += 1
	{ return 4 }
yy5:
	yycursor += 1
	yymarker = yycursor
	if (yylimit <= yycursor) {
		goto yy10
	}
	yych = yyinput[yycursor]
	switch (yych) {
	case 'c':
		goto yy6
	default:
		goto yy2
	}
yy6:
	yycursor += 1
	if (yylimit <= yycursor) {
		goto yy10
	}
	yych = yyinput[yycursor]
	switch (yych) {
	case 'c':
		goto yy6
	default:
		goto yy7
	}
yy7:
	yycursor = yymarker
	goto yy2
yy8:
	{ return 0 }
yy9:
	{ return 2 }
yy10:
	{ return 5 }
}

}

func lex_eof(str string) int {
	yyinput := str + "\000"
	yycursor := 0
	yymarker := 0
	yylimit := len(str)

	
{
	var yych byte
yyFillLabel0:
	yych = yyinput[yycursor]
	switch (yych) {
	case 'a':
		goto yy14
	case 'b':
		goto yy15
	case 'c':
		goto yy16
	default:
		if (yylimit <= yycursor) {
			if (false) {
				goto yyFillLabel0
			}
			goto yy19
		}
		goto yy12
	}
yy12:
	yycursor += 1
yy13:
	{ return 1 }
yy14:
	yycursor += 1
	if (yycursor == yylimit) {
		goto yy20
	}
	{ return 3 }
yy15:
	yycursor += 1
	{ return 4 }
yy16:
	yycursor += 1
	yymarker = yycursor
yyFillLabel1:
	yych = yyinput[yycursor]
	switch (yych) {
	case 'c':
		goto yy17
	default:
		if (yylimit <= yycursor) {
			if (false) {
				goto yyFillLabel1
			}
			goto yy21
		}
		goto yy13
	}
yy17:
	yycursor += 1
yyFillLabel2:
	yych = yyinput[yycursor]
	switch (yych) {
	case 'c':
		goto yy17
	default:
		if (yylimit <= yycursor) {
			if (false) {
				goto yyFillLabel2
			}
			goto yy21
		}
		goto yy18
	}
yy18:
	yycursor = yymarker
	goto yy13
yy19:
	{ return 0 }
yy20:
	{ return 2 }
yy21:
	{ return 5 }
}

}

const YYMAXFILL = 2


func lex_scc(str string) int {
	yyinput := str + strings.Repeat("\000", int(YYMAXFILL))
	yycursor := 0
	yymarker := 0
	yylimit := len(yyinput)
	end := len(str)

	
{
	var yych byte
	if (yycursor == end) {
		goto yy30
	}
	if ((yylimit - yycursor) < 2) {
		return -1
	}
	yych = yyinput[yycursor]
	switch (yych) {
	case 'a':
		goto yy25
	case 'b':
		goto yy26
	case 'c':
		goto yy27
	default:
		goto yy23
	}
yy23:
	yycursor += 1
yy24:
	{ return 1 }
yy25:
	yycursor += 1
	if (yycursor == end) {
		goto yy31
	}
	{ return 3 }
yy26:
	yycursor += 1
	{ return 4 }
yy27:
	yycursor += 1
	yymarker = yycursor
	if (yycursor == end) {
		goto yy32
	}
	yych = yyinput[yycursor]
	switch (yych) {
	case 'c':
		goto yy28
	default:
		goto yy24
	}
yy28:
	yycursor += 1
	if (yycursor == end) {
		goto yy32
	}
	if (yylimit <= yycursor) {
		return -1
	}
	yych = yyinput[yycursor]
	switch (yych) {
	case 'c':
		goto yy28
	default:
		goto yy29
	}
yy29:
	yycursor = yymarker
	goto yy24
yy30:
	{ return 0 }
yy31:
	{ return 2 }
yy32:
	{ return 5 }
}

}

func test(str string, ret int) {
	assert_eq := func(x, y int) { if x != y { panic("error") } }
	assert_eq(lex_simple(str), ret)
	assert_eq(lex_eof(str), ret)
	assert_eq(lex_scc(str), ret)
}

func main() {
	test("", 0)
	test("a", 2)
	test("ax", 3)
	test("b", 4)
	test("bx", 4)
	test("ccc", 5)
}
