-- Generated by re2hs
{-# LANGUAGE RecordWildCards #-}
-- re2hs $INPUT -o $OUTPUT -i
{-# OPTIONS_GHC -Wno-unused-record-wildcards #-}
{-# LANGUAGE OverloadedStrings #-}

import Control.Monad (when)
import Data.Array
import Data.Int
import Data.Word

data State a = State {
    _yyinput :: a,
    _yycursor :: Int
}




yy0 :: State (Array Int Word8) -> Bool
yy0 State{..} =
    let yych = (!) _yyinput _yycursor in
    let __ = _yycursor + 1 in let _yycursor = __ in
    if yych <= 0xFE then yy1 State{..}
    else yy2 State{..}

yy1 :: State (Array Int Word8) -> Bool
yy1 State{..} =
    False

yy2 :: State (Array Int Word8) -> Bool
yy2 State{..} =
    True

lex_unsigned :: State (Array Int Word8) -> Bool
lex_unsigned State{..} =
    yy0 State{..}




yy3 :: State (Array Int Int8) -> Bool
yy3 State{..} =
    let yych = (!) _yyinput _yycursor in
    let __ = _yycursor + 1 in let _yycursor = __ in
    if yych <= 0xFE then yy4 State{..}
    else yy5 State{..}

yy4 :: State (Array Int Int8) -> Bool
yy4 State{..} =
    False

yy5 :: State (Array Int Int8) -> Bool
yy5 State{..} =
    True

lex_signed :: State (Array Int Int8) -> Bool
lex_signed State{..} =
    yy3 State{..}



main :: IO ()
main = do
    let make_st l = State {
            _yyinput = listArray (0, length l - 1) l,
            _yycursor = 0}

    let u8 = [0x60] -- ok, 'a' should not match
    when (lex_unsigned (make_st u8) /= False) $ error "lex_unsigned"

    let s8 = [0x60] -- error, 'a' does match
    when (lex_signed (make_st s8) /= True) $ error "lex_signed"
