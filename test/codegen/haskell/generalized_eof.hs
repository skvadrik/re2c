-- Generated by re2hs
{-# LANGUAGE RecordWildCards #-}
-- re2hs $INPUT -o $OUTPUT -i
{-# OPTIONS_GHC -Wno-unused-record-wildcards #-}
{-# LANGUAGE OverloadedStrings #-}

import Control.Exception
import Control.Monad (when)
import qualified Data.ByteString as BS

data State = State {
    _yyinput :: BS.ByteString,
    _yycursor :: Int,
    _yymarker :: Int,
    _yylimit :: Int,
    _yyend :: Int
}

make_state :: BS.ByteString -> Int -> Int -> State
make_state s n m = State {
    _yyinput = s,
    _yycursor = 0,
    _yymarker = 0,
    _yylimit = n,
    _yyend = m}




yy0 :: State -> IO Int
yy0 State{..} = do
    if _yycursor >= _yylimit then do
        yy8 State{..}
    else do
        yych <- return $ BS.index _yyinput _yycursor
        _yycursor <- return $ _yycursor + 1
        case yych of
            _c | 0x61 == _c -> do
                yy3 State{..}
            _c | 0x62 == _c -> do
                yy4 State{..}
            _c | 0x63 == _c -> do
                yy5 State{..}
            _c | True -> do
                yy1 State{..}

yy1 :: State -> IO Int
yy1 State{..} = do
    yy2 State{..}

yy2 :: State -> IO Int
yy2 State{..} = do
    return 1

yy3 :: State -> IO Int
yy3 State{..} = do
    if _yycursor >= _yylimit then yy9 State{..}
    else return 3

yy4 :: State -> IO Int
yy4 State{..} = do
    return 4

yy5 :: State -> IO Int
yy5 State{..} = do
    let _yymarker = _yycursor
    if _yycursor >= _yylimit then do
        yy10 State{..}
    else do
        yych <- return $ BS.index _yyinput _yycursor
        case yych of
            _c | 0x63 == _c -> do
                _yycursor <- return $ _yycursor + 1
                yy6 State{..}
            _c | True -> do
                yy2 State{..}

yy6 :: State -> IO Int
yy6 State{..} = do
    if _yycursor >= _yylimit then do
        yy10 State{..}
    else do
        yych <- return $ BS.index _yyinput _yycursor
        case yych of
            _c | 0x63 == _c -> do
                _yycursor <- return $ _yycursor + 1
                yy6 State{..}
            _c | True -> do
                yy7 State{..}

yy7 :: State -> IO Int
yy7 State{..} = do
    let _yycursor = _yymarker
    yy2 State{..}

yy8 :: State -> IO Int
yy8 State{..} = do
    return 0

yy9 :: State -> IO Int
yy9 State{..} = do
    return 2

yy10 :: State -> IO Int
yy10 State{..} = do
    return 5

lex_simple :: State -> IO Int
lex_simple State{..} = do
    yy0 State{..}




yy11 :: State -> IO Int
yy11 State{..} = do
    yych <- return $ BS.index _yyinput _yycursor
    case yych of
        _c | 0x61 == _c -> do
            _yycursor <- return $ _yycursor + 1
            yy14 State{..}
        _c | 0x62 == _c -> do
            _yycursor <- return $ _yycursor + 1
            yy15 State{..}
        _c | 0x63 == _c -> do
            _yycursor <- return $ _yycursor + 1
            yy16 State{..}
        _c | True -> do
            if _yycursor >= _yylimit then do
                let yyfill = False
                if yyfill then yy11 State{..}
                else yy19 State{..}
            else do
                _yycursor <- return $ _yycursor + 1
                yy12 State{..}

yy12 :: State -> IO Int
yy12 State{..} = do
    yy13 State{..}

yy13 :: State -> IO Int
yy13 State{..} = do
    return 1

yy14 :: State -> IO Int
yy14 State{..} = do
    if _yycursor == _yylimit then yy20 State{..}
    else return 3

yy15 :: State -> IO Int
yy15 State{..} = do
    return 4

yy16 :: State -> IO Int
yy16 State{..} = do
    let _yymarker = _yycursor
    yych <- return $ BS.index _yyinput _yycursor
    case yych of
        _c | 0x63 == _c -> do
            _yycursor <- return $ _yycursor + 1
            yy17 State{..}
        _c | True -> do
            if _yycursor >= _yylimit then do
                let yyfill = False
                if yyfill then yy16 State{..}
                else yy21 State{..}
            else do
                yy13 State{..}

yy17 :: State -> IO Int
yy17 State{..} = do
    yych <- return $ BS.index _yyinput _yycursor
    case yych of
        _c | 0x63 == _c -> do
            _yycursor <- return $ _yycursor + 1
            yy17 State{..}
        _c | True -> do
            if _yycursor >= _yylimit then do
                let yyfill = False
                if yyfill then yy17 State{..}
                else yy21 State{..}
            else do
                yy18 State{..}

yy18 :: State -> IO Int
yy18 State{..} = do
    let _yycursor = _yymarker
    yy13 State{..}

yy19 :: State -> IO Int
yy19 State{..} = do
    return 0

yy20 :: State -> IO Int
yy20 State{..} = do
    return 2

yy21 :: State -> IO Int
yy21 State{..} = do
    return 5

lex_eof :: State -> IO Int
lex_eof State{..} = do
    yy11 State{..}



data FillException = UnexpectedFill deriving (Show)
instance Exception FillException

yymaxfill :: Int
yymaxfill = 2



yy22 :: State -> IO Int
yy22 State{..} = do
    if _yycursor == _yyend then do
        yy30 State{..}
    else do
        when (_yycursor >= _yylimit) $ throw UnexpectedFill
        yych <- return $ BS.index _yyinput _yycursor
        _yycursor <- return $ _yycursor + 1
        case yych of
            _c | 0x61 == _c -> do
                yy25 State{..}
            _c | 0x62 == _c -> do
                yy26 State{..}
            _c | 0x63 == _c -> do
                yy27 State{..}
            _c | True -> do
                yy23 State{..}

yy23 :: State -> IO Int
yy23 State{..} = do
    yy24 State{..}

yy24 :: State -> IO Int
yy24 State{..} = do
    return 1

yy25 :: State -> IO Int
yy25 State{..} = do
    if _yycursor == _yyend then yy31 State{..}
    else return 3

yy26 :: State -> IO Int
yy26 State{..} = do
    return 4

yy27 :: State -> IO Int
yy27 State{..} = do
    let _yymarker = _yycursor
    if _yycursor == _yyend then do
        yy32 State{..}
    else do
        yych <- return $ BS.index _yyinput _yycursor
        case yych of
            _c | 0x63 == _c -> do
                _yycursor <- return $ _yycursor + 1
                yy28 State{..}
            _c | True -> do
                yy24 State{..}

yy28 :: State -> IO Int
yy28 State{..} = do
    if _yycursor == _yyend then do
        yy32 State{..}
    else do
        when (_yycursor >= _yylimit) $ throw UnexpectedFill
        yych <- return $ BS.index _yyinput _yycursor
        case yych of
            _c | 0x63 == _c -> do
                _yycursor <- return $ _yycursor + 1
                yy28 State{..}
            _c | True -> do
                yy29 State{..}

yy29 :: State -> IO Int
yy29 State{..} = do
    let _yycursor = _yymarker
    yy24 State{..}

yy30 :: State -> IO Int
yy30 State{..} = do
    return 0

yy31 :: State -> IO Int
yy31 State{..} = do
    return 2

yy32 :: State -> IO Int
yy32 State{..} = do
    return 5

lex_scc :: State -> IO Int
lex_scc State{..} = do
    yy22 State{..}



main :: IO ()
main = do
    let test_simple s n = do
            m <- lex_simple $ make_state s (BS.length s - 1) 0
            when (m /= n) $ error "failed simple"

        test_eof s n = do
            m <- lex_eof $ make_state s (BS.length s - 1) 0
            when (m /= n) $ error "failed eof"

        test_scc s n = do
            let buf = BS.concat [s, BS.replicate yymaxfill 0]
            let st = make_state buf (BS.length buf) (BS.length s - 1)
            m <- catch (lex_scc st) (\(_ :: FillException) -> return (-1))
            when (m /= n) $ error "failed scc"

        test s n = do
            test_simple s n
            test_eof s n
            test_scc s n

    test "\0"  0
    test "a\0"  2
    test "ax\0"  3
    test "b\0"  4
    test "bx\0"  4
    test "ccc\0"  5
