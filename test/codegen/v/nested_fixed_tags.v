// Code generated by re2c, DO NOT EDIT.
// re2v $INPUT -o $OUTPUT -i



fn lex_tags(str string) int {
    mut cur, mut mar := 0, 0
    mut x, mut y := 0, 0
    mut yyt1 := -1
    
    mut yych := 0
    mar = cur
    yych = str[cur]
    match yych {
        0x62 { unsafe { goto yy2 } }
        else {
            yyt1 = -1
            unsafe { goto yy1 }
        }
    }
yy1:
    y = yyt1
    x = yyt1
    yyt1 = -1
    if x != yyt1 {
        x += -1
    }
    return if x == -1 { -1 } else { y - x }
yy2:
    cur += 1
    yych = str[cur]
    match yych {
        0x61 { unsafe { goto yy4 } }
        else { unsafe { goto yy3 } }
    }
yy3:
    cur = mar
    yyt1 = -1
    unsafe { goto yy1 }
yy4:
    cur += 1
    yyt1 = cur
    unsafe { goto yy1 }

}

const yymaxnmatch = 3


fn lex_captures(str string) int {
    mut cur := 0
    mut yypmatch := []int{len: yymaxnmatch * 2}
    mut yynmatch := 0
    mut yyt1 := -1
	mut yyt2 := -1
    
    mut yych := 0
    yych = str[cur]
    match yych {
        0x61 {
            yyt1 = cur
            unsafe { goto yy7 }
        }
        else {
            yyt1 = cur
            yyt2 = -1
            unsafe { goto yy6 }
        }
    }
yy6:
    yynmatch = 3
    yypmatch[0] = yyt1
    yypmatch[3] = yyt2
    yypmatch[5] = yyt2
    yypmatch[1] = cur
    yypmatch[2] = yyt2
    yyt2 = -1
    if yypmatch[2] != yyt2 {
        yypmatch[2] += -1
    }
    yypmatch[4] = yypmatch[2]
    
            if yynmatch != 3 { panic("wrong yynmatch!") }
            return yypmatch[4]

yy7:
    cur += 1
    yyt2 = cur
    unsafe { goto yy6 }

}

fn main() {
    assert_eq := fn (result int, expect int) { if result != expect { panic("error") } } 
    assert_eq(lex_tags("\0"), -1)
    assert_eq(lex_tags("ba\0"), 1)
    assert_eq(lex_captures("\0"), -1)
    assert_eq(lex_captures("a\0"), 0)
}
codegen/v/nested_fixed_tags.re:22:25: warning: rule matches empty string [-Wmatch-empty-string]
codegen/v/nested_fixed_tags.re:35:17: warning: rule matches empty string [-Wmatch-empty-string]
