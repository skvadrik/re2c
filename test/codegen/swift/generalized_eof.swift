/* Generated by re2swift */
// re2swift $INPUT -o $OUTPUT -i



func lex_simple(_ str: StaticString) -> Int {
    let yyinput = str.utf8Start
    let yylimit = str.utf8CodeUnitCount
    var yycursor = 0
    var yymarker = 0
    
  var yych: UInt8 = 0
  var yystate: UInt = 0
  yyl: while true {
    switch yystate {
      case 0:
        if yylimit <= yycursor {
          yystate = 8
          continue yyl
        }
        yych = yyinput[yycursor]
        yycursor += 1
        switch yych {
          case 0x61:
            yystate = 3
            continue yyl
          case 0x62:
            yystate = 4
            continue yyl
          case 0x63:
            yystate = 5
            continue yyl
          default:
            yystate = 1
            continue yyl
        }
      case 1:
        yystate = 2
        continue yyl
      case 2: return 1
      case 3:
        if yylimit <= yycursor {
          yystate = 9
          continue yyl
        }
        return 3
      case 4: return 4
      case 5:
        yymarker = yycursor
        if yylimit <= yycursor {
          yystate = 10
          continue yyl
        }
        yych = yyinput[yycursor]
        switch yych {
          case 0x63:
            yycursor += 1
            yystate = 6
            continue yyl
          default:
            yystate = 2
            continue yyl
        }
      case 6:
        if yylimit <= yycursor {
          yystate = 10
          continue yyl
        }
        yych = yyinput[yycursor]
        switch yych {
          case 0x63:
            yycursor += 1
            yystate = 6
            continue yyl
          default:
            yystate = 7
            continue yyl
        }
      case 7:
        yycursor = yymarker
        yystate = 2
        continue yyl
      case 8: return 0
      case 9: return 2
      case 10: return 5
      default: fatalError("internal lexer error")
    }
  }

}

func lex_eof(_ str: StaticString) -> Int {
    let yyinput = str.utf8Start
    let yylimit = str.utf8CodeUnitCount
    var yycursor = 0
    var yymarker = 0
    
  var yych: UInt8 = 0
  var yystate: UInt = 0
  yyl: while true {
    switch yystate {
      case 0:
        yych = yyinput[yycursor]
        switch yych {
          case 0x61:
            yycursor += 1
            yystate = 3
            continue yyl
          case 0x62:
            yycursor += 1
            yystate = 4
            continue yyl
          case 0x63:
            yycursor += 1
            yystate = 5
            continue yyl
          default:
            if yylimit <= yycursor {
              if false {
                yystate = 0
                continue yyl
              }
              yystate = 8
              continue yyl
            }
            yycursor += 1
            yystate = 1
            continue yyl
        }
      case 1:
        yystate = 2
        continue yyl
      case 2: return 1
      case 3:
        if yycursor == yylimit {
          yystate = 9
          continue yyl
        }
        return 3
      case 4: return 4
      case 5:
        yymarker = yycursor
        yych = yyinput[yycursor]
        switch yych {
          case 0x63:
            yycursor += 1
            yystate = 6
            continue yyl
          default:
            if yylimit <= yycursor {
              if false {
                yystate = 5
                continue yyl
              }
              yystate = 10
              continue yyl
            }
            yystate = 2
            continue yyl
        }
      case 6:
        yych = yyinput[yycursor]
        switch yych {
          case 0x63:
            yycursor += 1
            yystate = 6
            continue yyl
          default:
            if yylimit <= yycursor {
              if false {
                yystate = 6
                continue yyl
              }
              yystate = 10
              continue yyl
            }
            yystate = 7
            continue yyl
        }
      case 7:
        yycursor = yymarker
        yystate = 2
        continue yyl
      case 8: return 0
      case 9: return 2
      case 10: return 5
      default: fatalError("internal lexer error")
    }
  }

}

let yymaxfill = 2


func lex_scc(_ str: StaticString) -> Int {
    let yyinput =  str.withUTF8Buffer {
        ContiguousArray<UInt8>($0) + repeatElement(0, count: yymaxfill)
    }
    let end = str.utf8CodeUnitCount
    let yylimit = end + yymaxfill
    var yycursor = 0
    var yymarker = 0
    
  var yych: UInt8 = 0
  var yystate: UInt = 0
  yyl: while true {
    switch yystate {
      case 0:
        if yycursor == end {
          yystate = 8
          continue yyl
        }
        if (yylimit - yycursor) < 2 {
          return -1
        }
        yych = yyinput[yycursor]
        yycursor += 1
        switch yych {
          case 0x61:
            yystate = 3
            continue yyl
          case 0x62:
            yystate = 4
            continue yyl
          case 0x63:
            yystate = 5
            continue yyl
          default:
            yystate = 1
            continue yyl
        }
      case 1:
        yystate = 2
        continue yyl
      case 2: return 1
      case 3:
        if yycursor == end {
          yystate = 9
          continue yyl
        }
        return 3
      case 4: return 4
      case 5:
        yymarker = yycursor
        if yycursor == end {
          yystate = 10
          continue yyl
        }
        yych = yyinput[yycursor]
        switch yych {
          case 0x63:
            yycursor += 1
            yystate = 6
            continue yyl
          default:
            yystate = 2
            continue yyl
        }
      case 6:
        if yycursor == end {
          yystate = 10
          continue yyl
        }
        if yylimit <= yycursor {
          return -1
        }
        yych = yyinput[yycursor]
        switch yych {
          case 0x63:
            yycursor += 1
            yystate = 6
            continue yyl
          default:
            yystate = 7
            continue yyl
        }
      case 7:
        yycursor = yymarker
        yystate = 2
        continue yyl
      case 8: return 0
      case 9: return 2
      case 10: return 5
      default: fatalError("internal lexer error")
    }
  }

}

func test(_ s: StaticString, _ r: Int) {
    assert(lex_simple(s) == r)
    assert(lex_eof(s) == r)
    assert(lex_scc(s) == r)
}

test("", 0)
test("a", 2)
test("ax", 3)
test("b", 4)
test("bx", 4)
test("ccc", 5)
