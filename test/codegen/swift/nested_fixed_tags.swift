/* Generated by re2swift */
// re2swift $INPUT -o $OUTPUT -i











func lexTagsGeneric(_ str: UnsafeBufferPointer<UInt8>) -> Int {
  var yyt1 = -1
  
  var cursor = 0, marker = 0
  var x: Int, y: Int
  
  var yych: UInt8 = 0
  var yystate: UInt = 0
  yyl: while true {
    switch yystate {
      case 0:
        marker = cursor
        yych = str[cursor]
        switch yych {
          case 0x62:
            cursor += 1
            yystate = 2
            continue yyl
          default:
            yyt1 = -1
            yystate = 1
            continue yyl
        }
      case 1:
        y = yyt1
        x = yyt1
        yyt1 = -1
        if x != yyt1 {
          x += -1
        }
        return (x == -1) ? -1 : (y - x)
      case 2:
        yych = str[cursor]
        switch yych {
          case 0x61:
            cursor += 1
            yystate = 4
            continue yyl
          default:
            yystate = 3
            continue yyl
        }
      case 3:
        cursor = marker
        yyt1 = -1
        yystate = 1
        continue yyl
      case 4:
        yyt1 = cursor
        yystate = 1
        continue yyl
      default: fatalError("internal lexer error")
    }
  }

  return -2
}

func lexTagsSimple(_ str: UnsafeBufferPointer<UInt8>) -> Int {
  var yyt1 = -1
  
  var yycursor = 0, yymarker = 0
  var x: Int, y: Int
  
  var yych: UInt8 = 0
  var yystate: UInt = 0
  yyl: while true {
    switch yystate {
      case 0:
        yymarker = yycursor
        yych = str[yycursor]
        switch yych {
          case 0x62:
            yycursor += 1
            yystate = 2
            continue yyl
          default:
            yyt1 = -1
            yystate = 1
            continue yyl
        }
      case 1:
        y = yyt1
        x = yyt1
        if x != -1 {
          x -= 1
        }
        return (x == -1) ? -1 : (y - x)
      case 2:
        yych = str[yycursor]
        switch yych {
          case 0x61:
            yycursor += 1
            yystate = 4
            continue yyl
          default:
            yystate = 3
            continue yyl
        }
      case 3:
        yycursor = yymarker
        yyt1 = -1
        yystate = 1
        continue yyl
      case 4:
        yyt1 = yycursor
        yystate = 1
        continue yyl
      default: fatalError("internal lexer error")
    }
  }

}

func lexCapturesGeneric(_ str: UnsafeBufferPointer<UInt8>) -> Int {
  let yymaxnmatch = 3

  var yyt1 = -1
  var yyt2 = -1
  
  var cursor = 0, yynmatch: Int
  var yypmatch = [Int](repeating: 0, count: 2 * yymaxnmatch)
  
  var yych: UInt8 = 0
  var yystate: UInt = 0
  yyl: while true {
    switch yystate {
      case 0:
        yych = str[cursor]
        switch yych {
          case 0x61:
            yyt1 = cursor
            cursor += 1
            yystate = 2
            continue yyl
          default:
            yyt1 = cursor
            yyt2 = -1
            yystate = 1
            continue yyl
        }
      case 1:
        yynmatch = 3
        yypmatch[0] = yyt1
        yypmatch[3] = yyt2
        yypmatch[5] = yyt2
        yypmatch[1] = cursor
        yypmatch[2] = yyt2
        yyt2 = -1
        if yypmatch[2] != yyt2 {
          yypmatch[2] += -1
        }
        yypmatch[4] = yypmatch[2]
        
    assert(yynmatch == 3)
    return yypmatch[4]

      case 2:
        yyt2 = cursor
        yystate = 1
        continue yyl
      default: fatalError("internal lexer error")
    }
  }

}

func lexCapturesSimple(_ str: UnsafeBufferPointer<UInt8>) -> Int {
  let yymaxnmatch = 3

  var yyt1 = -1
  var yyt2 = -1
  
  var yycursor = 0, yynmatch: Int
  var yypmatch = [Int](repeating: 0, count: 2 * yymaxnmatch)
  
  var yych: UInt8 = 0
  var yystate: UInt = 0
  yyl: while true {
    switch yystate {
      case 0:
        yych = str[yycursor]
        switch yych {
          case 0x61:
            yyt1 = yycursor
            yycursor += 1
            yystate = 2
            continue yyl
          default:
            yyt1 = yycursor
            yyt2 = -1
            yystate = 1
            continue yyl
        }
      case 1:
        yynmatch = 3
        yypmatch[0] = yyt1
        yypmatch[3] = yyt2
        yypmatch[5] = yyt2
        yypmatch[1] = yycursor
        yypmatch[2] = yyt2
        if yypmatch[2] != -1 {
          yypmatch[2] -= 1
        }
        yypmatch[4] = yypmatch[2]
        
    assert(yynmatch == 3)
    return yypmatch[4]

      case 2:
        yyt2 = yycursor
        yystate = 1
        continue yyl
      default: fatalError("internal lexer error")
    }
  }

}

@main struct Program {
  static func test(call: (UnsafeBufferPointer<UInt8>) -> Int, string: StaticString, expect: Int) {
    string.withUTF8Buffer {
      assert(call($0) == expect)
    }
  }

  static func main() {
    test(call: lexTagsGeneric, string: "\0",   expect: -1)
    test(call: lexTagsGeneric, string: "ba\0", expect:  1)
    test(call: lexTagsSimple,  string: "\0",   expect: -1)
    test(call: lexTagsSimple,  string: "ba\0", expect:  1)
    test(call: lexCapturesGeneric, string: "\0",  expect: -1)
    test(call: lexCapturesGeneric, string: "a\0", expect:  0)
    test(call: lexCapturesSimple,  string: "\0",  expect: -1)
    test(call: lexCapturesSimple,  string: "a\0", expect:  0)
  }
}
codegen/swift/nested_fixed_tags.re:24:19: warning: rule matches empty string [-Wmatch-empty-string]
codegen/swift/nested_fixed_tags.re:24:19: warning: rule matches empty string [-Wmatch-empty-string]
codegen/swift/nested_fixed_tags.re:29:11: warning: rule matches empty string [-Wmatch-empty-string]
codegen/swift/nested_fixed_tags.re:29:11: warning: rule matches empty string [-Wmatch-empty-string]
