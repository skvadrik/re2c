// Generated by re2zig
// re2zig $INPUT -o $OUTPUT

const std = @import("std");



fn lex_unsigned(str: [:0]const u8) bool {
    var cur: u32 = 0;
    
    var yych: u8 = 0;
    var yystate: u32 = 0;
    yyl: while (true) {
        switch (yystate) {
            0 => {
                yych = str[cur];
                cur += 1;
                if (yych >= 0xFF) {
                    yystate = 1;
                    continue :yyl;
                }
                return false;
            },
            1 => { return true; },
            else => { @panic("internal lexer error"); },
        }
    }

}

fn lex_signed(str: [:0]const u8) bool {
    var cur: u32 = 0;
    
    var yych: i8 = 0;
    var yystate: u32 = 0;
    yyl: while (true) {
        switch (yystate) {
            0 => {
                yych = @bitCast(str[cur]);
                cur += 1;
                if (yych >= 0xFF) {
                    yystate = 1;
                    continue :yyl;
                }
                return false;
            },
            1 => { return true; },
            else => { @panic("internal lexer error"); },
        }
    }

}

test {
    try std.testing.expect(lex_unsigned("\xff"));
    try std.testing.expect(!lex_signed("\xff")); // error - lexer works incorrectly
}
