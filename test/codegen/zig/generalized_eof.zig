// Generated by re2zig
// re2zig $INPUT -o $OUTPUT

const std = @import("std");



fn lex_simple(yyinput: [:0]const u8) i32 {
    var yycursor: usize = 0;
    var yymarker: usize = 0;
    const yylimit: usize = yyinput.len;

    
    var yych: u8 = 0;
    var yystate: u32 = 0;
    yyl: while (true) {
        switch (yystate) {
            0 => {
                if (yylimit <= yycursor) {
                    yystate = 8;
                    continue :yyl;
                }
                yych = yyinput[yycursor];
                yycursor += 1;
                switch (yych) {
                    0x61 => {
                        yystate = 3;
                        continue :yyl;
                    },
                    0x62 => {
                        yystate = 4;
                        continue :yyl;
                    },
                    0x63 => {
                        yystate = 5;
                        continue :yyl;
                    },
                    else => {
                        yystate = 1;
                        continue :yyl;
                    },
                }
            },
            1 => {
                yystate = 2;
                continue :yyl;
            },
            2 => { return 1; },
            3 => {
                if (yylimit <= yycursor) {
                    yystate = 9;
                    continue :yyl;
                }
                return 3;
            },
            4 => { return 4; },
            5 => {
                yymarker = yycursor;
                if (yylimit <= yycursor) {
                    yystate = 10;
                    continue :yyl;
                }
                yych = yyinput[yycursor];
                switch (yych) {
                    0x63 => {
                        yycursor += 1;
                        yystate = 6;
                        continue :yyl;
                    },
                    else => {
                        yystate = 2;
                        continue :yyl;
                    },
                }
            },
            6 => {
                if (yylimit <= yycursor) {
                    yystate = 10;
                    continue :yyl;
                }
                yych = yyinput[yycursor];
                switch (yych) {
                    0x63 => {
                        yycursor += 1;
                        yystate = 6;
                        continue :yyl;
                    },
                    else => {
                        yystate = 7;
                        continue :yyl;
                    },
                }
            },
            7 => {
                yycursor = yymarker;
                yystate = 2;
                continue :yyl;
            },
            8 => { return 0; },
            9 => { return 2; },
            10 => { return 5; },
            else => { @panic("internal lexer error"); },
        }
    }

}

fn lex_eof(yyinput: [:0]const u8) i32 {
    var yycursor: usize = 0;
    var yymarker: usize = 0;
    const yylimit: usize = yyinput.len;

    
    var yych: u8 = 0;
    var yystate: u32 = 0;
    yyl: while (true) {
        switch (yystate) {
            0 => {
                yych = yyinput[yycursor];
                switch (yych) {
                    0x61 => {
                        yycursor += 1;
                        yystate = 3;
                        continue :yyl;
                    },
                    0x62 => {
                        yycursor += 1;
                        yystate = 4;
                        continue :yyl;
                    },
                    0x63 => {
                        yycursor += 1;
                        yystate = 5;
                        continue :yyl;
                    },
                    else => {
                        if (yylimit <= yycursor) {
                            if (false) {
                                yystate = 0;
                                continue :yyl;
                            }
                            yystate = 8;
                            continue :yyl;
                        }
                        yycursor += 1;
                        yystate = 1;
                        continue :yyl;
                    },
                }
            },
            1 => {
                yystate = 2;
                continue :yyl;
            },
            2 => { return 1; },
            3 => {
                if (yycursor == yylimit) {
                    yystate = 9;
                    continue :yyl;
                }
                return 3;
            },
            4 => { return 4; },
            5 => {
                yymarker = yycursor;
                yych = yyinput[yycursor];
                switch (yych) {
                    0x63 => {
                        yycursor += 1;
                        yystate = 6;
                        continue :yyl;
                    },
                    else => {
                        if (yylimit <= yycursor) {
                            if (false) {
                                yystate = 5;
                                continue :yyl;
                            }
                            yystate = 10;
                            continue :yyl;
                        }
                        yystate = 2;
                        continue :yyl;
                    },
                }
            },
            6 => {
                yych = yyinput[yycursor];
                switch (yych) {
                    0x63 => {
                        yycursor += 1;
                        yystate = 6;
                        continue :yyl;
                    },
                    else => {
                        if (yylimit <= yycursor) {
                            if (false) {
                                yystate = 6;
                                continue :yyl;
                            }
                            yystate = 10;
                            continue :yyl;
                        }
                        yystate = 7;
                        continue :yyl;
                    },
                }
            },
            7 => {
                yycursor = yymarker;
                yystate = 2;
                continue :yyl;
            },
            8 => { return 0; },
            9 => { return 2; },
            10 => { return 5; },
            else => { @panic("internal lexer error"); },
        }
    }

}

const yymaxfill = 2;


fn lex_scc(str: [:0]const u8) !i32 {
    var yycursor: usize = 0;
    var yymarker: usize = 0;
    const end: usize = str.len;
    const yylimit: usize = end + yymaxfill;

    var yyinput = try std.testing.allocator.alloc(u8, yylimit);
    defer std.testing.allocator.free(yyinput);
    std.mem.copyForwards(u8, yyinput[0..], str);
    std.mem.copyForwards(u8, yyinput[end..], &[_]u8{0} ** yymaxfill);

    
    var yych: u8 = 0;
    var yystate: u32 = 0;
    yyl: while (true) {
        switch (yystate) {
            0 => {
                if (yycursor == end) {
                    yystate = 8;
                    continue :yyl;
                }
                if ((yylimit - yycursor) < 2) { return -1; }
                yych = yyinput[yycursor];
                yycursor += 1;
                switch (yych) {
                    0x61 => {
                        yystate = 3;
                        continue :yyl;
                    },
                    0x62 => {
                        yystate = 4;
                        continue :yyl;
                    },
                    0x63 => {
                        yystate = 5;
                        continue :yyl;
                    },
                    else => {
                        yystate = 1;
                        continue :yyl;
                    },
                }
            },
            1 => {
                yystate = 2;
                continue :yyl;
            },
            2 => { return 1; },
            3 => {
                if (yycursor == end) {
                    yystate = 9;
                    continue :yyl;
                }
                return 3;
            },
            4 => { return 4; },
            5 => {
                yymarker = yycursor;
                if (yycursor == end) {
                    yystate = 10;
                    continue :yyl;
                }
                yych = yyinput[yycursor];
                switch (yych) {
                    0x63 => {
                        yycursor += 1;
                        yystate = 6;
                        continue :yyl;
                    },
                    else => {
                        yystate = 2;
                        continue :yyl;
                    },
                }
            },
            6 => {
                if (yycursor == end) {
                    yystate = 10;
                    continue :yyl;
                }
                if (yylimit <= yycursor) { return -1; }
                yych = yyinput[yycursor];
                switch (yych) {
                    0x63 => {
                        yycursor += 1;
                        yystate = 6;
                        continue :yyl;
                    },
                    else => {
                        yystate = 7;
                        continue :yyl;
                    },
                }
            },
            7 => {
                yycursor = yymarker;
                yystate = 2;
                continue :yyl;
            },
            8 => { return 0; },
            9 => { return 2; },
            10 => { return 5; },
            else => { @panic("internal lexer error"); },
        }
    }

}

fn run(str: [:0]const u8, ret: i32) !void {
    try std.testing.expectEqual(lex_simple(str), ret);
    try std.testing.expectEqual(lex_eof(str), ret);
    try std.testing.expectEqual(try lex_scc(str), ret);
}

test {
    try run("", 0);
    try run("a", 2);
    try run("ax", 3);
    try run("b", 4);
    try run("bx", 4);
    try run("ccc", 5);
}
