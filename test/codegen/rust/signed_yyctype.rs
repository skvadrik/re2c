/* Generated by re2rust */
// re2rust $INPUT -o $OUTPUT --api simple



fn lex_unsigned(yyinput: &[u8]) -> bool {
    let mut yycursor = 0;
    
{
    #[allow(unused_assignments)]
    let mut yych : u8 = 0;
    let mut yystate : usize = 0;
    'yyl: loop {
        match yystate {
            0 => {
                yych = unsafe {*yyinput.get_unchecked(yycursor)};
                yycursor += 1;
                if yych >= 0xFF {
                    yystate = 1;
                    continue 'yyl;
                }
                { return false; }
            }
            1 => { return true; },
            _ => panic!("internal lexer error"),
        }
    }
}

}

#[allow(overflowing_literals)]
fn lex_signed(yyinput: &[u8]) -> bool {
    let mut yycursor = 0;
    
{
    #[allow(unused_assignments)]
    let mut yych : i8 = 0;
    let mut yystate : usize = 0;
    'yyl: loop {
        match yystate {
            0 => {
                yych = unsafe {*yyinput.get_unchecked(yycursor)} as i8;
                yycursor += 1;
                if yych >= 0xFF {
                    yystate = 1;
                    continue 'yyl;
                }
                { return false; }
            }
            1 => { return true; },
            _ => panic!("internal lexer error"),
        }
    }
}

}

fn main() {
    assert!(!lex_unsigned(b"a\0")); // ok, 'a' should not match
    assert!(lex_signed(b"a\0")); // error, 'a' does match
}
