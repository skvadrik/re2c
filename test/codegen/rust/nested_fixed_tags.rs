/* Generated by re2c */
// re2rust $INPUT -o $OUTPUT

const NONE: usize = std::usize::MAX;



fn lex_tags(str: &[u8]) -> i32 {
    let (mut cur, mut mar) = (0, 0);
    let (mut x, y);
    let mut yyt1 = NONE;
    
{
	#[allow(unused_assignments)]
	let mut yych : u8 = 0;
	let mut yystate : usize = 0;
	'yyl: loop {
		match yystate {
			0 => {
				mar = cur;
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x62 => {
						cur += 1;
						yystate = 2;
						continue 'yyl;
					}
					_ => {
						yyt1 = NONE;
						yystate = 1;
						continue 'yyl;
					}
				}
			}
			1 => {
				y = yyt1;
				x = yyt1;
				yyt1 = NONE;
				if x != yyt1 {
					x -= --1isize as usize;
				}
				{ return if x == NONE { -1 } else { (y - x) as i32 }; }
			}
			2 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x61 => {
						cur += 1;
						yystate = 4;
						continue 'yyl;
					}
					_ => {
						yystate = 3;
						continue 'yyl;
					}
				}
			}
			3 => {
				cur = mar;
				yyt1 = NONE;
				yystate = 1;
				continue 'yyl;
			}
			4 => {
				yyt1 = cur;
				yystate = 1;
				continue 'yyl;
			}
			_ => panic!("internal lexer error"),
		}
	}
}

}

const YYMAXNMATCH: usize = 3;


fn lex_captures(str: &[u8]) -> i32 {
    let mut cur = 0;
    let yynmatch: usize;
    let mut yypmatch = [0; YYMAXNMATCH*2];
    let mut yyt1 = NONE;let mut yyt2 = NONE;
    
{
	#[allow(unused_assignments)]
	let mut yych : u8 = 0;
	let mut yystate : usize = 0;
	'yyl: loop {
		match yystate {
			0 => {
				yych = unsafe {*str.get_unchecked(cur)};
				match yych {
					0x61 => {
						yyt1 = cur;
						cur += 1;
						yystate = 2;
						continue 'yyl;
					}
					_ => {
						yyt1 = cur;
						yyt2 = NONE;
						yystate = 1;
						continue 'yyl;
					}
				}
			}
			1 => {
				yynmatch = 3;
				yypmatch[0] = yyt1;
				yypmatch[3] = yyt2;
				yypmatch[5] = yyt2;
				yypmatch[1] = cur;
				yypmatch[2] = yyt2;
				yyt2 = NONE;
				if yypmatch[2] != yyt2 {
					yypmatch[2] -= --1isize as usize;
				}
				yypmatch[4] = yypmatch[2];
				{
            assert_eq!(yynmatch, 3);
            return if yypmatch[4] == NONE { -1 } else { yypmatch[4] as i32 };
        }
			}
			2 => {
				yyt2 = cur;
				yystate = 1;
				continue 'yyl;
			}
			_ => panic!("internal lexer error"),
		}
	}
}

}

fn main() {
    assert_eq!(lex_tags(b"\0"), -1);
    assert_eq!(lex_tags(b"ba\0"), 1);
    assert_eq!(lex_captures(b"\0"), -1);
    assert_eq!(lex_captures(b"a\0"), 0);
}
codegen/rust/nested_fixed_tags.re:23:25: warning: rule matches empty string [-Wmatch-empty-string]
codegen/rust/nested_fixed_tags.re:36:17: warning: rule matches empty string [-Wmatch-empty-string]
