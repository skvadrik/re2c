/* Generated by re2rust */
// re2rust $INPUT -o $OUTPUT --api simple



fn lex_simple(yyinput: &[u8]) -> isize {
    let mut yycursor = 0;
    let mut yymarker = 0;
    let yylimit = yyinput.len() - 1;
    
{
    #[allow(unused_assignments)]
    let mut yych : u8 = 0;
    let mut yystate : usize = 0;
    'yyl: loop {
        match yystate {
            0 => {
                if yylimit <= yycursor {
                    yystate = 8;
                    continue 'yyl;
                }
                yych = unsafe {*yyinput.get_unchecked(yycursor)};
                yycursor += 1;
                match yych {
                    0x61 => {
                        yystate = 3;
                        continue 'yyl;
                    }
                    0x62 => {
                        yystate = 4;
                        continue 'yyl;
                    }
                    0x63 => {
                        yystate = 5;
                        continue 'yyl;
                    }
                    _ => {
                        yystate = 1;
                        continue 'yyl;
                    }
                }
            }
            1 => {
                yystate = 2;
                continue 'yyl;
            }
            2 => { return 1; },
            3 => {
                if yylimit <= yycursor {
                    yystate = 9;
                    continue 'yyl;
                }
                { return 3; }
            }
            4 => { return 4; },
            5 => {
                yymarker = yycursor;
                if yylimit <= yycursor {
                    yystate = 10;
                    continue 'yyl;
                }
                yych = unsafe {*yyinput.get_unchecked(yycursor)};
                match yych {
                    0x63 => {
                        yycursor += 1;
                        yystate = 6;
                        continue 'yyl;
                    }
                    _ => {
                        yystate = 2;
                        continue 'yyl;
                    }
                }
            }
            6 => {
                if yylimit <= yycursor {
                    yystate = 10;
                    continue 'yyl;
                }
                yych = unsafe {*yyinput.get_unchecked(yycursor)};
                match yych {
                    0x63 => {
                        yycursor += 1;
                        yystate = 6;
                        continue 'yyl;
                    }
                    _ => {
                        yystate = 7;
                        continue 'yyl;
                    }
                }
            }
            7 => {
                yycursor = yymarker;
                yystate = 2;
                continue 'yyl;
            }
            8 => { return 0; },
            9 => { return 2; },
            10 => { return 5; },
            _ => panic!("internal lexer error"),
        }
    }
}

}

fn lex_eof(yyinput: &[u8]) -> isize {
    let mut yycursor = 0;
    let mut yymarker = 0;
    let yylimit = yyinput.len() - 1;
    
{
    #[allow(unused_assignments)]
    let mut yych : u8 = 0;
    let mut yystate : usize = 0;
    'yyl: loop {
        match yystate {
            0 => {
                yych = unsafe {*yyinput.get_unchecked(yycursor)};
                match yych {
                    0x61 => {
                        yycursor += 1;
                        yystate = 3;
                        continue 'yyl;
                    }
                    0x62 => {
                        yycursor += 1;
                        yystate = 4;
                        continue 'yyl;
                    }
                    0x63 => {
                        yycursor += 1;
                        yystate = 5;
                        continue 'yyl;
                    }
                    _ => {
                        if yylimit <= yycursor {
                            if false {
                                yystate = 0;
                                continue 'yyl;
                            }
                            yystate = 8;
                            continue 'yyl;
                        }
                        yycursor += 1;
                        yystate = 1;
                        continue 'yyl;
                    }
                }
            }
            1 => {
                yystate = 2;
                continue 'yyl;
            }
            2 => { return 1; },
            3 => {
                if yycursor == yylimit {
                    yystate = 9;
                    continue 'yyl;
                }
                { return 3; }
            }
            4 => { return 4; },
            5 => {
                yymarker = yycursor;
                yych = unsafe {*yyinput.get_unchecked(yycursor)};
                match yych {
                    0x63 => {
                        yycursor += 1;
                        yystate = 6;
                        continue 'yyl;
                    }
                    _ => {
                        if yylimit <= yycursor {
                            if false {
                                yystate = 5;
                                continue 'yyl;
                            }
                            yystate = 10;
                            continue 'yyl;
                        }
                        yystate = 2;
                        continue 'yyl;
                    }
                }
            }
            6 => {
                yych = unsafe {*yyinput.get_unchecked(yycursor)};
                match yych {
                    0x63 => {
                        yycursor += 1;
                        yystate = 6;
                        continue 'yyl;
                    }
                    _ => {
                        if yylimit <= yycursor {
                            if false {
                                yystate = 6;
                                continue 'yyl;
                            }
                            yystate = 10;
                            continue 'yyl;
                        }
                        yystate = 7;
                        continue 'yyl;
                    }
                }
            }
            7 => {
                yycursor = yymarker;
                yystate = 2;
                continue 'yyl;
            }
            8 => { return 0; },
            9 => { return 2; },
            10 => { return 5; },
            _ => panic!("internal lexer error"),
        }
    }
}

}

const YYMAXFILL: usize = 2;


fn lex_scc(s: &[u8]) -> isize {
    let mut yycursor = 0;
    let mut yymarker = 0;
    let yylimit = s.len() + YYMAXFILL;
    let end = s.len() - 1;

    // Copy string to a buffer and add YYMAXFILL zero padding.
    let mut yyinput = Vec::with_capacity(yylimit);
    yyinput.extend_from_slice(s);
    yyinput.extend([0 as u8; YYMAXFILL]);

    
{
    #[allow(unused_assignments)]
    let mut yych : u8 = 0;
    let mut yystate : usize = 0;
    'yyl: loop {
        match yystate {
            0 => {
                if yycursor == end {
                    yystate = 8;
                    continue 'yyl;
                }
                if (yylimit - yycursor) < 2 {
                    return -1;
                }
                yych = unsafe {*yyinput.get_unchecked(yycursor)};
                yycursor += 1;
                match yych {
                    0x61 => {
                        yystate = 3;
                        continue 'yyl;
                    }
                    0x62 => {
                        yystate = 4;
                        continue 'yyl;
                    }
                    0x63 => {
                        yystate = 5;
                        continue 'yyl;
                    }
                    _ => {
                        yystate = 1;
                        continue 'yyl;
                    }
                }
            }
            1 => {
                yystate = 2;
                continue 'yyl;
            }
            2 => { return 1; },
            3 => {
                if yycursor == end {
                    yystate = 9;
                    continue 'yyl;
                }
                { return 3; }
            }
            4 => { return 4; },
            5 => {
                yymarker = yycursor;
                if yycursor == end {
                    yystate = 10;
                    continue 'yyl;
                }
                yych = unsafe {*yyinput.get_unchecked(yycursor)};
                match yych {
                    0x63 => {
                        yycursor += 1;
                        yystate = 6;
                        continue 'yyl;
                    }
                    _ => {
                        yystate = 2;
                        continue 'yyl;
                    }
                }
            }
            6 => {
                if yycursor == end {
                    yystate = 10;
                    continue 'yyl;
                }
                if yylimit <= yycursor {
                    return -1;
                }
                yych = unsafe {*yyinput.get_unchecked(yycursor)};
                match yych {
                    0x63 => {
                        yycursor += 1;
                        yystate = 6;
                        continue 'yyl;
                    }
                    _ => {
                        yystate = 7;
                        continue 'yyl;
                    }
                }
            }
            7 => {
                yycursor = yymarker;
                yystate = 2;
                continue 'yyl;
            }
            8 => { return 0; },
            9 => { return 2; },
            10 => { return 5; },
            _ => panic!("internal lexer error"),
        }
    }
}

}

fn test(s: &[u8], r: isize) {
    assert_eq!(lex_simple(s), r);
    assert_eq!(lex_eof(s), r);
    assert_eq!(lex_scc(s), r);
}

fn main() {
    test(b"\x00", 0);
    test(b"a\x00", 2);
    test(b"ax\x00", 3);
    test(b"b\x00", 4);
    test(b"bx\x00", 4);
    test(b"ccc\x00", 5);
}
