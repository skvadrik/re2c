/* Generated by re2c */

#include <stdio.h>
#include <stdlib.h> /* malloc, free */

static void * read_file
    ( const char * fname
    , size_t unit
    , size_t padding
    , size_t * pfsize
    )
{
    void * buffer = NULL;
    size_t fsize = 0;

    /* open file */
    FILE * f = fopen (fname, "rb");
    if (f == NULL)
    {
        goto error;
    }

    /* get file size */
    fseek (f, 0, SEEK_END);
    fsize = (size_t) ftell (f) / unit;
    fseek (f, 0, SEEK_SET);

    /* allocate memory for file and padding */
    buffer = malloc (unit * (fsize + padding));
    if (buffer == NULL)
    {
        goto error;
    }

    /* read the whole file in memory */
    if (fread (buffer, unit, fsize, f) != fsize)
    {
        goto error;
    }

    fclose (f);
    *pfsize = fsize;
    return buffer;

error:
    fprintf (stderr, "error: cannot read file '%s'\n", fname);
    free (buffer);
    if (f != NULL)
    {
        fclose (f);
    }
    return NULL;
}

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line344
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line344: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line344: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line344 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line344.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line344.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych >= 0x0080) goto yy4;
        YYSKIP ();
        status = action_line344 (i, keys, input, token, &cursor, 0);
        continue;
yy4:
        YYSKIP ();
        status = action_line344 (i, keys, input, token, &cursor, 4294967294);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line344: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line344: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line351
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line351: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line351: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line351 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line351.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line351.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x007F) goto yy8;
        if (yych <= 0x00FF) goto yy10;
yy8:
        YYSKIP ();
        status = action_line351 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy10:
        YYSKIP ();
        status = action_line351 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line351: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line351: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line358
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line358: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line358: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line358 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line358.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line358.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x00FF) goto yy14;
        if (yych <= 0x017F) goto yy16;
yy14:
        YYSKIP ();
        status = action_line358 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy16:
        YYSKIP ();
        status = action_line358 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line358: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line358: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line365
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line365: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line365: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line365 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line365.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line365.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x017F) goto yy20;
        if (yych <= 0x024F) goto yy22;
yy20:
        YYSKIP ();
        status = action_line365 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy22:
        YYSKIP ();
        status = action_line365 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line365: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line365: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line372
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line372: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line372: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line372 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line372.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line372.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x024F) goto yy26;
        if (yych <= 0x02AF) goto yy28;
yy26:
        YYSKIP ();
        status = action_line372 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy28:
        YYSKIP ();
        status = action_line372 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line372: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line372: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line379
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line379: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line379: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line379 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line379.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line379.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x02AF) goto yy32;
        if (yych <= 0x02FF) goto yy34;
yy32:
        YYSKIP ();
        status = action_line379 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy34:
        YYSKIP ();
        status = action_line379 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line379: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line379: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line386
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line386: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line386: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line386 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line386.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line386.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x02FF) goto yy38;
        if (yych <= 0x036F) goto yy40;
yy38:
        YYSKIP ();
        status = action_line386 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy40:
        YYSKIP ();
        status = action_line386 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line386: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line386: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line393
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line393: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line393: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line393 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line393.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line393.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x036F) goto yy44;
        if (yych <= 0x03FF) goto yy46;
yy44:
        YYSKIP ();
        status = action_line393 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy46:
        YYSKIP ();
        status = action_line393 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line393: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line393: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line400
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line400: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line400: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line400 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line400.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line400.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x03FF) goto yy50;
        if (yych <= 0x04FF) goto yy52;
yy50:
        YYSKIP ();
        status = action_line400 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy52:
        YYSKIP ();
        status = action_line400 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line400: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line400: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line407
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line407: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line407: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line407 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line407.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line407.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x04FF) goto yy56;
        if (yych <= 0x052F) goto yy58;
yy56:
        YYSKIP ();
        status = action_line407 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy58:
        YYSKIP ();
        status = action_line407 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line407: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line407: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line414
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line414: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line414: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line414 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line414.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line414.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x052F) goto yy62;
        if (yych <= 0x058F) goto yy64;
yy62:
        YYSKIP ();
        status = action_line414 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy64:
        YYSKIP ();
        status = action_line414 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line414: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line414: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line421
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line421: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line421: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line421 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line421.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line421.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x058F) goto yy68;
        if (yych <= 0x05FF) goto yy70;
yy68:
        YYSKIP ();
        status = action_line421 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy70:
        YYSKIP ();
        status = action_line421 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line421: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line421: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line428
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line428: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line428: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line428 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line428.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line428.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x05FF) goto yy74;
        if (yych <= 0x06FF) goto yy76;
yy74:
        YYSKIP ();
        status = action_line428 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy76:
        YYSKIP ();
        status = action_line428 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line428: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line428: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line435
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line435: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line435: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line435 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line435.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line435.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x06FF) goto yy80;
        if (yych <= 0x074F) goto yy82;
yy80:
        YYSKIP ();
        status = action_line435 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy82:
        YYSKIP ();
        status = action_line435 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line435: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line435: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line442
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line442: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line442: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line442 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line442.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line442.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x077F) goto yy86;
        if (yych <= 0x07BF) goto yy88;
yy86:
        YYSKIP ();
        status = action_line442 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy88:
        YYSKIP ();
        status = action_line442 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line442: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line442: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line449
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line449: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line449: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line449 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line449.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line449.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x08FF) goto yy92;
        if (yych <= 0x097F) goto yy94;
yy92:
        YYSKIP ();
        status = action_line449 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy94:
        YYSKIP ();
        status = action_line449 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line449: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line449: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line456
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line456: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line456: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line456 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line456.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line456.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x097F) goto yy98;
        if (yych <= 0x09FF) goto yy100;
yy98:
        YYSKIP ();
        status = action_line456 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy100:
        YYSKIP ();
        status = action_line456 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line456: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line456: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line463
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line463: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line463: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line463 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line463.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line463.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x09FF) goto yy104;
        if (yych <= 0x0A7F) goto yy106;
yy104:
        YYSKIP ();
        status = action_line463 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy106:
        YYSKIP ();
        status = action_line463 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line463: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line463: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line470
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line470: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line470: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line470 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line470.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line470.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x0A7F) goto yy110;
        if (yych <= 0x0AFF) goto yy112;
yy110:
        YYSKIP ();
        status = action_line470 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy112:
        YYSKIP ();
        status = action_line470 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line470: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line470: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line477
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line477: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line477: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line477 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line477.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line477.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x0AFF) goto yy116;
        if (yych <= 0x0B7F) goto yy118;
yy116:
        YYSKIP ();
        status = action_line477 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy118:
        YYSKIP ();
        status = action_line477 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line477: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line477: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line484
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line484: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line484: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line484 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line484.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line484.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x0B7F) goto yy122;
        if (yych <= 0x0BFF) goto yy124;
yy122:
        YYSKIP ();
        status = action_line484 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy124:
        YYSKIP ();
        status = action_line484 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line484: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line484: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line491
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line491: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line491: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line491 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line491.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line491.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x0BFF) goto yy128;
        if (yych <= 0x0C7F) goto yy130;
yy128:
        YYSKIP ();
        status = action_line491 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy130:
        YYSKIP ();
        status = action_line491 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line491: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line491: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line498
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line498: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line498: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line498 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line498.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line498.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x0C7F) goto yy134;
        if (yych <= 0x0CFF) goto yy136;
yy134:
        YYSKIP ();
        status = action_line498 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy136:
        YYSKIP ();
        status = action_line498 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line498: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line498: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line505
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line505: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line505: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line505 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line505.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line505.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x0CFF) goto yy140;
        if (yych <= 0x0D7F) goto yy142;
yy140:
        YYSKIP ();
        status = action_line505 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy142:
        YYSKIP ();
        status = action_line505 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line505: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line505: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line512
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line512: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line512: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line512 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line512.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line512.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x0D7F) goto yy146;
        if (yych <= 0x0DFF) goto yy148;
yy146:
        YYSKIP ();
        status = action_line512 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy148:
        YYSKIP ();
        status = action_line512 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line512: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line512: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line519
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line519: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line519: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line519 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line519.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line519.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x0DFF) goto yy152;
        if (yych <= 0x0E7F) goto yy154;
yy152:
        YYSKIP ();
        status = action_line519 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy154:
        YYSKIP ();
        status = action_line519 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line519: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line519: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line526
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line526: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line526: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line526 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line526.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line526.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x0E7F) goto yy158;
        if (yych <= 0x0EFF) goto yy160;
yy158:
        YYSKIP ();
        status = action_line526 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy160:
        YYSKIP ();
        status = action_line526 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line526: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line526: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line533
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line533: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line533: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line533 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line533.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line533.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x0EFF) goto yy164;
        if (yych <= 0x0FFF) goto yy166;
yy164:
        YYSKIP ();
        status = action_line533 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy166:
        YYSKIP ();
        status = action_line533 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line533: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line533: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line540
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line540: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line540: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line540 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line540.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line540.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x0FFF) goto yy170;
        if (yych <= 0x109F) goto yy172;
yy170:
        YYSKIP ();
        status = action_line540 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy172:
        YYSKIP ();
        status = action_line540 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line540: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line540: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line547
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line547: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line547: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line547 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line547.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line547.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x109F) goto yy176;
        if (yych <= 0x10FF) goto yy178;
yy176:
        YYSKIP ();
        status = action_line547 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy178:
        YYSKIP ();
        status = action_line547 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line547: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line547: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line554
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line554: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line554: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line554 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line554.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line554.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x10FF) goto yy182;
        if (yych <= 0x11FF) goto yy184;
yy182:
        YYSKIP ();
        status = action_line554 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy184:
        YYSKIP ();
        status = action_line554 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line554: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line554: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line561
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line561: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line561: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line561 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line561.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line561.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x11FF) goto yy188;
        if (yych <= 0x137F) goto yy190;
yy188:
        YYSKIP ();
        status = action_line561 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy190:
        YYSKIP ();
        status = action_line561 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line561: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line561: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line568
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line568: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line568: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line568 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line568.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line568.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x139F) goto yy194;
        if (yych <= 0x13FF) goto yy196;
yy194:
        YYSKIP ();
        status = action_line568 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy196:
        YYSKIP ();
        status = action_line568 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line568: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line568: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line575
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line575: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line575: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line575 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line575.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line575.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x13FF) goto yy200;
        if (yych <= 0x167F) goto yy202;
yy200:
        YYSKIP ();
        status = action_line575 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy202:
        YYSKIP ();
        status = action_line575 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line575: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line575: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line582
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line582: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line582: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line582 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line582.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line582.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x167F) goto yy206;
        if (yych <= 0x169F) goto yy208;
yy206:
        YYSKIP ();
        status = action_line582 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy208:
        YYSKIP ();
        status = action_line582 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line582: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line582: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line589
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line589: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line589: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line589 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line589.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line589.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x169F) goto yy212;
        if (yych <= 0x16FF) goto yy214;
yy212:
        YYSKIP ();
        status = action_line589 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy214:
        YYSKIP ();
        status = action_line589 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line589: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line589: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line596
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line596: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line596: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line596 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line596.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line596.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x16FF) goto yy218;
        if (yych <= 0x171F) goto yy220;
yy218:
        YYSKIP ();
        status = action_line596 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy220:
        YYSKIP ();
        status = action_line596 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line596: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line596: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line603
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line603: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line603: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line603 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line603.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line603.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x171F) goto yy224;
        if (yych <= 0x173F) goto yy226;
yy224:
        YYSKIP ();
        status = action_line603 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy226:
        YYSKIP ();
        status = action_line603 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line603: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line603: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line610
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line610: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line610: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line610 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line610.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line610.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x173F) goto yy230;
        if (yych <= 0x175F) goto yy232;
yy230:
        YYSKIP ();
        status = action_line610 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy232:
        YYSKIP ();
        status = action_line610 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line610: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line610: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line617
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line617: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line617: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line617 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line617.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line617.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x175F) goto yy236;
        if (yych <= 0x177F) goto yy238;
yy236:
        YYSKIP ();
        status = action_line617 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy238:
        YYSKIP ();
        status = action_line617 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line617: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line617: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line624
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line624: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line624: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line624 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line624.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line624.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x177F) goto yy242;
        if (yych <= 0x17FF) goto yy244;
yy242:
        YYSKIP ();
        status = action_line624 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy244:
        YYSKIP ();
        status = action_line624 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line624: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line624: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line631
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line631: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line631: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line631 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line631.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line631.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x17FF) goto yy248;
        if (yych <= 0x18AF) goto yy250;
yy248:
        YYSKIP ();
        status = action_line631 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy250:
        YYSKIP ();
        status = action_line631 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line631: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line631: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line638
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line638: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line638: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line638 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line638.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line638.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x18FF) goto yy254;
        if (yych <= 0x194F) goto yy256;
yy254:
        YYSKIP ();
        status = action_line638 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy256:
        YYSKIP ();
        status = action_line638 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line638: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line638: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line645
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line645: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line645: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line645 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line645.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line645.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x194F) goto yy260;
        if (yych <= 0x197F) goto yy262;
yy260:
        YYSKIP ();
        status = action_line645 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy262:
        YYSKIP ();
        status = action_line645 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line645: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line645: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line652
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line652: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line652: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line652 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line652.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line652.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x19DF) goto yy266;
        if (yych <= 0x19FF) goto yy268;
yy266:
        YYSKIP ();
        status = action_line652 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy268:
        YYSKIP ();
        status = action_line652 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line652: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line652: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line659
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line659: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line659: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line659 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line659.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line659.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x1CFF) goto yy272;
        if (yych <= 0x1D7F) goto yy274;
yy272:
        YYSKIP ();
        status = action_line659 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy274:
        YYSKIP ();
        status = action_line659 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line659: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line659: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line666
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line666: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line666: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line666 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line666.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line666.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x1DFF) goto yy278;
        if (yych <= 0x1EFF) goto yy280;
yy278:
        YYSKIP ();
        status = action_line666 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy280:
        YYSKIP ();
        status = action_line666 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line666: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line666: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line673
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line673: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line673: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line673 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line673.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line673.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x1EFF) goto yy284;
        if (yych <= 0x1FFF) goto yy286;
yy284:
        YYSKIP ();
        status = action_line673 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy286:
        YYSKIP ();
        status = action_line673 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line673: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line673: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line680
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line680: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line680: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line680 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line680.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line680.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x1FFF) goto yy290;
        if (yych <= 0x206F) goto yy292;
yy290:
        YYSKIP ();
        status = action_line680 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy292:
        YYSKIP ();
        status = action_line680 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line680: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line680: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line687
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line687: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line687: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line687 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line687.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line687.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x206F) goto yy296;
        if (yych <= 0x209F) goto yy298;
yy296:
        YYSKIP ();
        status = action_line687 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy298:
        YYSKIP ();
        status = action_line687 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line687: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line687: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line694
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line694: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line694: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line694 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line694.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line694.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x209F) goto yy302;
        if (yych <= 0x20CF) goto yy304;
yy302:
        YYSKIP ();
        status = action_line694 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy304:
        YYSKIP ();
        status = action_line694 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line694: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line694: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line701
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line701: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line701: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line701 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line701.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line701.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x20CF) goto yy308;
        if (yych <= 0x20FF) goto yy310;
yy308:
        YYSKIP ();
        status = action_line701 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy310:
        YYSKIP ();
        status = action_line701 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line701: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line701: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line708
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line708: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line708: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line708 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line708.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line708.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x20FF) goto yy314;
        if (yych <= 0x214F) goto yy316;
yy314:
        YYSKIP ();
        status = action_line708 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy316:
        YYSKIP ();
        status = action_line708 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line708: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line708: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line715
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line715: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line715: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line715 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line715.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line715.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x214F) goto yy320;
        if (yych <= 0x218F) goto yy322;
yy320:
        YYSKIP ();
        status = action_line715 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy322:
        YYSKIP ();
        status = action_line715 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line715: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line715: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line722
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line722: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line722: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line722 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line722.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line722.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x218F) goto yy326;
        if (yych <= 0x21FF) goto yy328;
yy326:
        YYSKIP ();
        status = action_line722 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy328:
        YYSKIP ();
        status = action_line722 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line722: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line722: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line729
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line729: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line729: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line729 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line729.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line729.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x21FF) goto yy332;
        if (yych <= 0x22FF) goto yy334;
yy332:
        YYSKIP ();
        status = action_line729 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy334:
        YYSKIP ();
        status = action_line729 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line729: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line729: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line736
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line736: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line736: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line736 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line736.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line736.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x22FF) goto yy338;
        if (yych <= 0x23FF) goto yy340;
yy338:
        YYSKIP ();
        status = action_line736 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy340:
        YYSKIP ();
        status = action_line736 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line736: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line736: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line743
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line743: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line743: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line743 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line743.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line743.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x23FF) goto yy344;
        if (yych <= 0x243F) goto yy346;
yy344:
        YYSKIP ();
        status = action_line743 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy346:
        YYSKIP ();
        status = action_line743 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line743: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line743: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line750
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line750: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line750: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line750 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line750.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line750.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x243F) goto yy350;
        if (yych <= 0x245F) goto yy352;
yy350:
        YYSKIP ();
        status = action_line750 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy352:
        YYSKIP ();
        status = action_line750 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line750: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line750: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line757
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line757: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line757: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line757 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line757.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line757.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x245F) goto yy356;
        if (yych <= 0x24FF) goto yy358;
yy356:
        YYSKIP ();
        status = action_line757 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy358:
        YYSKIP ();
        status = action_line757 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line757: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line757: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line764
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line764: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line764: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line764 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line764.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line764.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x24FF) goto yy362;
        if (yych <= 0x257F) goto yy364;
yy362:
        YYSKIP ();
        status = action_line764 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy364:
        YYSKIP ();
        status = action_line764 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line764: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line764: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line771
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line771: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line771: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line771 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line771.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line771.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x257F) goto yy368;
        if (yych <= 0x259F) goto yy370;
yy368:
        YYSKIP ();
        status = action_line771 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy370:
        YYSKIP ();
        status = action_line771 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line771: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line771: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line778
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line778: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line778: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line778 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line778.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line778.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x259F) goto yy374;
        if (yych <= 0x25FF) goto yy376;
yy374:
        YYSKIP ();
        status = action_line778 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy376:
        YYSKIP ();
        status = action_line778 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line778: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line778: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line785
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line785: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line785: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line785 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line785.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line785.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x25FF) goto yy380;
        if (yych <= 0x26FF) goto yy382;
yy380:
        YYSKIP ();
        status = action_line785 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy382:
        YYSKIP ();
        status = action_line785 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line785: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line785: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line792
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line792: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line792: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line792 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line792.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line792.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x26FF) goto yy386;
        if (yych <= 0x27BF) goto yy388;
yy386:
        YYSKIP ();
        status = action_line792 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy388:
        YYSKIP ();
        status = action_line792 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line792: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line792: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line799
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line799: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line799: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line799 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line799.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line799.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x27BF) goto yy392;
        if (yych <= 0x27EF) goto yy394;
yy392:
        YYSKIP ();
        status = action_line799 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy394:
        YYSKIP ();
        status = action_line799 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line799: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line799: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line806
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line806: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line806: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line806 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line806.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line806.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x27EF) goto yy398;
        if (yych <= 0x27FF) goto yy400;
yy398:
        YYSKIP ();
        status = action_line806 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy400:
        YYSKIP ();
        status = action_line806 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line806: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line806: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line813
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line813: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line813: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line813 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line813.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line813.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x27FF) goto yy404;
        if (yych <= 0x28FF) goto yy406;
yy404:
        YYSKIP ();
        status = action_line813 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy406:
        YYSKIP ();
        status = action_line813 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line813: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line813: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line820
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line820: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line820: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line820 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line820.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line820.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x28FF) goto yy410;
        if (yych <= 0x297F) goto yy412;
yy410:
        YYSKIP ();
        status = action_line820 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy412:
        YYSKIP ();
        status = action_line820 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line820: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line820: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line827
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line827: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line827: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line827 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line827.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line827.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x297F) goto yy416;
        if (yych <= 0x29FF) goto yy418;
yy416:
        YYSKIP ();
        status = action_line827 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy418:
        YYSKIP ();
        status = action_line827 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line827: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line827: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line834
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line834: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line834: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line834 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line834.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line834.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x29FF) goto yy422;
        if (yych <= 0x2AFF) goto yy424;
yy422:
        YYSKIP ();
        status = action_line834 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy424:
        YYSKIP ();
        status = action_line834 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line834: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line834: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line841
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line841: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line841: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line841 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line841.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line841.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x2AFF) goto yy428;
        if (yych <= 0x2BFF) goto yy430;
yy428:
        YYSKIP ();
        status = action_line841 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy430:
        YYSKIP ();
        status = action_line841 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line841: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line841: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line848
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line848: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line848: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line848 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line848.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line848.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x2E7F) goto yy434;
        if (yych <= 0x2EFF) goto yy436;
yy434:
        YYSKIP ();
        status = action_line848 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy436:
        YYSKIP ();
        status = action_line848 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line848: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line848: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line855
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line855: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line855: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line855 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line855.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line855.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x2EFF) goto yy440;
        if (yych <= 0x2FDF) goto yy442;
yy440:
        YYSKIP ();
        status = action_line855 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy442:
        YYSKIP ();
        status = action_line855 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line855: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line855: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line862
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line862: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line862: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line862 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line862.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line862.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x2FEF) goto yy446;
        if (yych <= 0x2FFF) goto yy448;
yy446:
        YYSKIP ();
        status = action_line862 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy448:
        YYSKIP ();
        status = action_line862 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line862: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line862: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line869
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line869: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line869: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line869 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line869.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line869.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x2FFF) goto yy452;
        if (yych <= 0x303F) goto yy454;
yy452:
        YYSKIP ();
        status = action_line869 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy454:
        YYSKIP ();
        status = action_line869 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line869: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line869: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line876
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line876: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line876: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line876 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line876.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line876.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x303F) goto yy458;
        if (yych <= 0x309F) goto yy460;
yy458:
        YYSKIP ();
        status = action_line876 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy460:
        YYSKIP ();
        status = action_line876 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line876: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line876: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line883
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line883: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line883: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line883 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line883.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line883.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x309F) goto yy464;
        if (yych <= 0x30FF) goto yy466;
yy464:
        YYSKIP ();
        status = action_line883 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy466:
        YYSKIP ();
        status = action_line883 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line883: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line883: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line890
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line890: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line890: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line890 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line890.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line890.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x30FF) goto yy470;
        if (yych <= 0x312F) goto yy472;
yy470:
        YYSKIP ();
        status = action_line890 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy472:
        YYSKIP ();
        status = action_line890 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line890: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line890: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line897
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line897: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line897: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line897 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line897.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line897.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x312F) goto yy476;
        if (yych <= 0x318F) goto yy478;
yy476:
        YYSKIP ();
        status = action_line897 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy478:
        YYSKIP ();
        status = action_line897 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line897: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line897: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line904
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line904: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line904: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line904 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line904.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line904.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x318F) goto yy482;
        if (yych <= 0x319F) goto yy484;
yy482:
        YYSKIP ();
        status = action_line904 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy484:
        YYSKIP ();
        status = action_line904 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line904: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line904: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line911
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line911: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line911: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line911 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line911.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line911.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x319F) goto yy488;
        if (yych <= 0x31BF) goto yy490;
yy488:
        YYSKIP ();
        status = action_line911 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy490:
        YYSKIP ();
        status = action_line911 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line911: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line911: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line918
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line918: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line918: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line918 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line918.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line918.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x31EF) goto yy494;
        if (yych <= 0x31FF) goto yy496;
yy494:
        YYSKIP ();
        status = action_line918 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy496:
        YYSKIP ();
        status = action_line918 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line918: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line918: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line925
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line925: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line925: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line925 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line925.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line925.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x31FF) goto yy500;
        if (yych <= 0x32FF) goto yy502;
yy500:
        YYSKIP ();
        status = action_line925 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy502:
        YYSKIP ();
        status = action_line925 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line925: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line925: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line932
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line932: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line932: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line932 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line932.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line932.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x32FF) goto yy506;
        if (yych <= 0x33FF) goto yy508;
yy506:
        YYSKIP ();
        status = action_line932 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy508:
        YYSKIP ();
        status = action_line932 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line932: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line932: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line939
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line939: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line939: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line939 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line939.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line939.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x33FF) goto yy512;
        if (yych <= 0x4DBF) goto yy514;
yy512:
        YYSKIP ();
        status = action_line939 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy514:
        YYSKIP ();
        status = action_line939 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line939: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line939: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line946
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line946: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line946: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line946 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line946.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line946.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x4DBF) goto yy518;
        if (yych <= 0x4DFF) goto yy520;
yy518:
        YYSKIP ();
        status = action_line946 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy520:
        YYSKIP ();
        status = action_line946 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line946: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line946: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line953
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line953: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line953: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line953 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line953.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line953.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x4DFF) goto yy524;
        if (yych <= 0x9FFF) goto yy526;
yy524:
        YYSKIP ();
        status = action_line953 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy526:
        YYSKIP ();
        status = action_line953 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line953: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line953: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line960
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line960: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line960: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line960 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line960.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line960.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x9FFF) goto yy530;
        if (yych <= 0xA48F) goto yy532;
yy530:
        YYSKIP ();
        status = action_line960 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy532:
        YYSKIP ();
        status = action_line960 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line960: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line960: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line967
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line967: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line967: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line967 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line967.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line967.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0xA48F) goto yy536;
        if (yych <= 0xA4CF) goto yy538;
yy536:
        YYSKIP ();
        status = action_line967 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy538:
        YYSKIP ();
        status = action_line967 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line967: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line967: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line974
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line974: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line974: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line974 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line974.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line974.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0xABFF) goto yy542;
        if (yych <= 0xD7AF) goto yy544;
yy542:
        YYSKIP ();
        status = action_line974 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy544:
        YYSKIP ();
        status = action_line974 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line974: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line974: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line981
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line981: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line981: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line981 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line981.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line981.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0xD7FF) goto yy548;
        if (yych <= 0xDB7F) goto yy550;
yy548:
        YYSKIP ();
        status = action_line981 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy550:
        YYSKIP ();
        status = action_line981 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line981: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line981: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line988
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line988: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line988: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line988 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line988.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line988.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0xDB7F) goto yy554;
        if (yych <= 0xDBFF) goto yy556;
yy554:
        YYSKIP ();
        status = action_line988 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy556:
        YYSKIP ();
        status = action_line988 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line988: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line988: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line995
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line995: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line995: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line995 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line995.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line995.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0xDBFF) goto yy560;
        if (yych <= 0xDFFF) goto yy562;
yy560:
        YYSKIP ();
        status = action_line995 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy562:
        YYSKIP ();
        status = action_line995 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line995: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line995: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line1002
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line1002: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line1002: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line1002 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line1002.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line1002.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0xDFFF) goto yy566;
        if (yych <= 0xF8FF) goto yy568;
yy566:
        YYSKIP ();
        status = action_line1002 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy568:
        YYSKIP ();
        status = action_line1002 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line1002: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line1002: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line1009
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line1009: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line1009: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line1009 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line1009.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line1009.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0xF8FF) goto yy572;
        if (yych <= 0xFAFF) goto yy574;
yy572:
        YYSKIP ();
        status = action_line1009 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy574:
        YYSKIP ();
        status = action_line1009 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line1009: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line1009: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line1016
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line1016: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line1016: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line1016 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line1016.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line1016.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0xFAFF) goto yy578;
        if (yych <= 0xFB4F) goto yy580;
yy578:
        YYSKIP ();
        status = action_line1016 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy580:
        YYSKIP ();
        status = action_line1016 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line1016: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line1016: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line1023
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line1023: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line1023: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line1023 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line1023.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line1023.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0xFB4F) goto yy584;
        if (yych <= 0xFDFF) goto yy586;
yy584:
        YYSKIP ();
        status = action_line1023 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy586:
        YYSKIP ();
        status = action_line1023 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line1023: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line1023: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line1030
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line1030: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line1030: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line1030 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line1030.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line1030.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0xFDFF) goto yy590;
        if (yych <= 0xFE0F) goto yy592;
yy590:
        YYSKIP ();
        status = action_line1030 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy592:
        YYSKIP ();
        status = action_line1030 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line1030: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line1030: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line1037
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line1037: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line1037: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line1037 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line1037.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line1037.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0xFE1F) goto yy596;
        if (yych <= 0xFE2F) goto yy598;
yy596:
        YYSKIP ();
        status = action_line1037 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy598:
        YYSKIP ();
        status = action_line1037 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line1037: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line1037: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line1044
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line1044: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line1044: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line1044 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line1044.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line1044.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0xFE2F) goto yy602;
        if (yych <= 0xFE4F) goto yy604;
yy602:
        YYSKIP ();
        status = action_line1044 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy604:
        YYSKIP ();
        status = action_line1044 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line1044: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line1044: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line1051
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line1051: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line1051: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line1051 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line1051.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line1051.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0xFE4F) goto yy608;
        if (yych <= 0xFE6F) goto yy610;
yy608:
        YYSKIP ();
        status = action_line1051 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy610:
        YYSKIP ();
        status = action_line1051 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line1051: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line1051: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line1058
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line1058: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line1058: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line1058 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line1058.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line1058.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0xFE6F) goto yy614;
        if (yych <= 0xFEFF) goto yy616;
yy614:
        YYSKIP ();
        status = action_line1058 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy616:
        YYSKIP ();
        status = action_line1058 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line1058: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line1058: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line1065
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line1065: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line1065: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line1065 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line1065.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line1065.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0xFEFF) goto yy620;
        if (yych <= 0xFFEF) goto yy622;
yy620:
        YYSKIP ();
        status = action_line1065 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy622:
        YYSKIP ();
        status = action_line1065 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line1065: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line1065: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line1072
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line1072: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line1072: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line1072 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line1072.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line1072.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych >= 0xFFF0) goto yy628;
        YYSKIP ();
        status = action_line1072 (i, keys, input, token, &cursor, 4294967294);
        continue;
yy628:
        YYSKIP ();
        status = action_line1072 (i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line1072: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line1072: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned short
#define YYKEYTYPE unsigned int
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line1079
    ( unsigned int i
    , const YYKEYTYPE * keys
    , const YYCTYPE * start
    , const YYCTYPE * token
    , const YYCTYPE ** cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 4294967295)
    {
        fprintf
            ( stderr
            , "warning: lex_line1079: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp)
    {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    }
    else
    {
        fprintf
            ( stderr
            , "error: lex_line1079: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line1079 ()
{
    const size_t padding = 1; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE * input = NULL;
    YYKEYTYPE * keys = NULL;
    const YYCTYPE * cursor = NULL;
    const YYCTYPE * limit = NULL;
    const YYCTYPE * token = NULL;
    const YYCTYPE * eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("<stdout>.line1079.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL)
    {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("<stdout>.line1079.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL)
    {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i)
    {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        if (yych <= 0x1D7F) {
            if (yych <= 0x139F) {
                if (yych <= 0x07BF) {
                    if (yych <= 0x074F) goto yy632;
                    if (yych <= 0x077F) goto yy634;
                } else {
                    if (yych <= 0x08FF) goto yy634;
                    if (yych >= 0x1380) goto yy634;
                }
            } else {
                if (yych <= 0x197F) {
                    if (yych <= 0x18AF) goto yy632;
                    if (yych <= 0x18FF) goto yy634;
                } else {
                    if (yych <= 0x19DF) goto yy634;
                    if (yych <= 0x19FF) goto yy632;
                    if (yych <= 0x1CFF) goto yy634;
                }
            }
        } else {
            if (yych <= 0x31EF) {
                if (yych <= 0x2E7F) {
                    if (yych <= 0x1DFF) goto yy634;
                    if (yych >= 0x2C00) goto yy634;
                } else {
                    if (yych <= 0x2FDF) goto yy632;
                    if (yych <= 0x2FEF) goto yy634;
                    if (yych >= 0x31C0) goto yy634;
                }
            } else {
                if (yych <= 0xD7AF) {
                    if (yych <= 0xA4CF) goto yy632;
                    if (yych <= 0xABFF) goto yy634;
                } else {
                    if (yych <= 0xD7FF) goto yy634;
                    if (yych <= 0xFE0F) goto yy632;
                    if (yych <= 0xFE1F) goto yy634;
                }
            }
        }
yy632:
        YYSKIP ();
        status = action_line1079 (i, keys, input, token, &cursor, 0);
        continue;
yy634:
        YYSKIP ();
        status = action_line1079 (i, keys, input, token, &cursor, 4294967294);
        continue;

    }
    if (status == 0)
    {
        if (cursor != eof)
        {
            status = 1;
            const long pos = token - input;
            fprintf (stderr, "error: lex_line1079: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count)
        {
            status = 1;
            fprintf (stderr, "error: lex_line1079: unused keys left after %u iterations\n", i);
        }
    }

end:
    free (input);
    free (keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

int main ()
{
    if (lex_line1002 () != 0) return 1;
    if (lex_line1009 () != 0) return 1;
    if (lex_line1016 () != 0) return 1;
    if (lex_line1023 () != 0) return 1;
    if (lex_line1030 () != 0) return 1;
    if (lex_line1037 () != 0) return 1;
    if (lex_line1044 () != 0) return 1;
    if (lex_line1051 () != 0) return 1;
    if (lex_line1058 () != 0) return 1;
    if (lex_line1065 () != 0) return 1;
    if (lex_line1072 () != 0) return 1;
    if (lex_line1079 () != 0) return 1;
    if (lex_line344 () != 0) return 1;
    if (lex_line351 () != 0) return 1;
    if (lex_line358 () != 0) return 1;
    if (lex_line365 () != 0) return 1;
    if (lex_line372 () != 0) return 1;
    if (lex_line379 () != 0) return 1;
    if (lex_line386 () != 0) return 1;
    if (lex_line393 () != 0) return 1;
    if (lex_line400 () != 0) return 1;
    if (lex_line407 () != 0) return 1;
    if (lex_line414 () != 0) return 1;
    if (lex_line421 () != 0) return 1;
    if (lex_line428 () != 0) return 1;
    if (lex_line435 () != 0) return 1;
    if (lex_line442 () != 0) return 1;
    if (lex_line449 () != 0) return 1;
    if (lex_line456 () != 0) return 1;
    if (lex_line463 () != 0) return 1;
    if (lex_line470 () != 0) return 1;
    if (lex_line477 () != 0) return 1;
    if (lex_line484 () != 0) return 1;
    if (lex_line491 () != 0) return 1;
    if (lex_line498 () != 0) return 1;
    if (lex_line505 () != 0) return 1;
    if (lex_line512 () != 0) return 1;
    if (lex_line519 () != 0) return 1;
    if (lex_line526 () != 0) return 1;
    if (lex_line533 () != 0) return 1;
    if (lex_line540 () != 0) return 1;
    if (lex_line547 () != 0) return 1;
    if (lex_line554 () != 0) return 1;
    if (lex_line561 () != 0) return 1;
    if (lex_line568 () != 0) return 1;
    if (lex_line575 () != 0) return 1;
    if (lex_line582 () != 0) return 1;
    if (lex_line589 () != 0) return 1;
    if (lex_line596 () != 0) return 1;
    if (lex_line603 () != 0) return 1;
    if (lex_line610 () != 0) return 1;
    if (lex_line617 () != 0) return 1;
    if (lex_line624 () != 0) return 1;
    if (lex_line631 () != 0) return 1;
    if (lex_line638 () != 0) return 1;
    if (lex_line645 () != 0) return 1;
    if (lex_line652 () != 0) return 1;
    if (lex_line659 () != 0) return 1;
    if (lex_line666 () != 0) return 1;
    if (lex_line673 () != 0) return 1;
    if (lex_line680 () != 0) return 1;
    if (lex_line687 () != 0) return 1;
    if (lex_line694 () != 0) return 1;
    if (lex_line701 () != 0) return 1;
    if (lex_line708 () != 0) return 1;
    if (lex_line715 () != 0) return 1;
    if (lex_line722 () != 0) return 1;
    if (lex_line729 () != 0) return 1;
    if (lex_line736 () != 0) return 1;
    if (lex_line743 () != 0) return 1;
    if (lex_line750 () != 0) return 1;
    if (lex_line757 () != 0) return 1;
    if (lex_line764 () != 0) return 1;
    if (lex_line771 () != 0) return 1;
    if (lex_line778 () != 0) return 1;
    if (lex_line785 () != 0) return 1;
    if (lex_line792 () != 0) return 1;
    if (lex_line799 () != 0) return 1;
    if (lex_line806 () != 0) return 1;
    if (lex_line813 () != 0) return 1;
    if (lex_line820 () != 0) return 1;
    if (lex_line827 () != 0) return 1;
    if (lex_line834 () != 0) return 1;
    if (lex_line841 () != 0) return 1;
    if (lex_line848 () != 0) return 1;
    if (lex_line855 () != 0) return 1;
    if (lex_line862 () != 0) return 1;
    if (lex_line869 () != 0) return 1;
    if (lex_line876 () != 0) return 1;
    if (lex_line883 () != 0) return 1;
    if (lex_line890 () != 0) return 1;
    if (lex_line897 () != 0) return 1;
    if (lex_line904 () != 0) return 1;
    if (lex_line911 () != 0) return 1;
    if (lex_line918 () != 0) return 1;
    if (lex_line925 () != 0) return 1;
    if (lex_line932 () != 0) return 1;
    if (lex_line939 () != 0) return 1;
    if (lex_line946 () != 0) return 1;
    if (lex_line953 () != 0) return 1;
    if (lex_line960 () != 0) return 1;
    if (lex_line967 () != 0) return 1;
    if (lex_line974 () != 0) return 1;
    if (lex_line981 () != 0) return 1;
    if (lex_line988 () != 0) return 1;
    if (lex_line995 () != 0) return 1;
    return 0;
}
                                                 " $ ##                                              	
 

                                              0 100                                                                                             /11011                                                                                                #@$ $?$                                              ' (''                                                                                             OP                                              2 4 33                                              0 /                                              1111                                              () ))                                              p o                                               P! !O!                                              3M 4M                                                                                                                                            p   o                                               OpPo                                              O 	   +.//11   P  ,.//11                                                                                                                                                                                                                                                                                                                                                                                                                                                        !                                                M NMM                                              ) + **                                                                                                                                                                                                                                          P O                                              % &%%                                              	 
		                                                                                             ! "!!                                              /P0O                                                                                                                                              ''''                                              / 0//                                                                                             . /..                                              ) *))                                                                                             1 211                                                                                             ' ) ((                                                                                                                                ! # ""                                              0 /                                                                                              &' ''                                                                                              OP                                              
 

                                                                                             P O                                              o  p                                                                                                	 		                                                                                             %%%%                                              1111                                              _`                                              @ ?                                              ?00@00                                              PO                                                                                                                                           P O                                                                                                                                            /@0 0?0                                                                                                                                 ?$`$@$_$                                                                                                                                            * , ++                                              $% %%                                                                                                                                                ?`@_                                              o p                                              _$ %`$$                                                                                             O!!P!!                                              /0                                              % ' &&                                                                                              1 3 22                                                                                                                                            o p                                                                                                                                                                                             O P                                                                                                                                             M  N                                              ./ //                                              
                                                                                             001 1/1                                            