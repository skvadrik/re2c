/* Generated by re2c */

#include <stdio.h>
#include <stdlib.h> /* malloc, free */

static void *read_file
    ( const char *fname
    , size_t unit
    , size_t padding
    , size_t *pfsize
    )
{
    void *buffer = NULL;
    size_t fsize = 0;

    /* open file */
    FILE *f = fopen(fname, "rb");
    if(f == NULL) {
        goto error;
    }

    /* get file size */
    fseek(f, 0, SEEK_END);
    fsize = (size_t) ftell(f) / unit;
    fseek(f, 0, SEEK_SET);

    /* allocate memory for file and padding */
    buffer = malloc(unit * (fsize + padding));
    if (buffer == NULL) {
        goto error;
    }

    /* read the whole file in memory */
    if (fread(buffer, unit, fsize, f) != fsize) {
        goto error;
    }

    fclose(f);
    *pfsize = fsize;
    return buffer;

error:
    fprintf(stderr, "error: cannot read file '%s'\n", fname);
    free(buffer);
    if (f != NULL) {
        fclose(f);
    }
    return NULL;
}

#define YYCTYPE unsigned char
#define YYKEYTYPE unsigned char
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYBACKUP() marker = cursor
#define YYRESTORE() cursor = marker
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line144
    ( unsigned int i
    , const YYKEYTYPE *keys
    , const YYCTYPE *start
    , const YYCTYPE *token
    , const YYCTYPE **cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 255) {
        fprintf
            ( stderr
            , "warning: lex_line144: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp) {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    } else {
        fprintf
            ( stderr
            , "error: lex_line144: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line144()
{
    const size_t padding = 11; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE *input = NULL;
    YYKEYTYPE *keys = NULL;
    const YYCTYPE *cursor = NULL;
    const YYCTYPE *limit = NULL;
    const YYCTYPE *token = NULL;
    const YYCTYPE *eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("scanner.S.c.line144.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL) {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("scanner.S.c.line144.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL) {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i) {
        token = cursor;
        const YYCTYPE *marker = NULL;
        YYCTYPE yych;

        if (YYLESSTHAN (11)) YYFILL(11);
        yych = YYPEEK ();
        switch (yych) {
        case 0x00:    goto yy7;
        case '\n':    goto yy5;
        case '*':    goto yy4;
        case '/':    goto yy2;
        default:    goto yy9;
        }
yy2:
        YYSKIP ();
        YYBACKUP ();
        yych = YYPEEK ();
        switch (yych) {
        case '*':    goto yy12;
        default:    goto yy3;
        }
yy3:
        status = action_line144(i, keys, input, token, &cursor, 5);
        continue;
yy4:
        YYSKIP ();
        yych = YYPEEK ();
        switch (yych) {
        case '/':    goto yy10;
        default:    goto yy3;
        }
yy5:
        YYSKIP ();
        status = action_line144(i, keys, input, token, &cursor, 3);
        continue;
yy7:
        YYSKIP ();
        status = action_line144(i, keys, input, token, &cursor, 4);
        continue;
yy9:
        YYSKIP ();
        yych = YYPEEK ();
        goto yy3;
yy10:
        YYSKIP ();
        status = action_line144(i, keys, input, token, &cursor, 2);
        continue;
yy12:
        YYSKIP ();
        yych = YYPEEK ();
        switch (yych) {
        case '!':    goto yy14;
        default:    goto yy13;
        }
yy13:
        YYRESTORE ();
        goto yy3;
yy14:
        YYSKIP ();
        yych = YYPEEK ();
        switch (yych) {
        case 'm':    goto yy15;
        case 'r':    goto yy16;
        default:    goto yy13;
        }
yy15:
        YYSKIP ();
        yych = YYPEEK ();
        switch (yych) {
        case 'a':    goto yy21;
        default:    goto yy13;
        }
yy16:
        YYSKIP ();
        yych = YYPEEK ();
        switch (yych) {
        case 'e':    goto yy17;
        default:    goto yy13;
        }
yy17:
        YYSKIP ();
        yych = YYPEEK ();
        switch (yych) {
        case '2':    goto yy18;
        default:    goto yy13;
        }
yy18:
        YYSKIP ();
        yych = YYPEEK ();
        switch (yych) {
        case 'c':    goto yy19;
        default:    goto yy13;
        }
yy19:
        YYSKIP ();
        status = action_line144(i, keys, input, token, &cursor, 0);
        continue;
yy21:
        YYSKIP ();
        yych = YYPEEK ();
        switch (yych) {
        case 'x':    goto yy22;
        default:    goto yy13;
        }
yy22:
        YYSKIP ();
        yych = YYPEEK ();
        switch (yych) {
        case ':':    goto yy23;
        default:    goto yy13;
        }
yy23:
        YYSKIP ();
        yych = YYPEEK ();
        switch (yych) {
        case 'r':    goto yy24;
        default:    goto yy13;
        }
yy24:
        YYSKIP ();
        yych = YYPEEK ();
        switch (yych) {
        case 'e':    goto yy25;
        default:    goto yy13;
        }
yy25:
        YYSKIP ();
        yych = YYPEEK ();
        switch (yych) {
        case '2':    goto yy26;
        default:    goto yy13;
        }
yy26:
        YYSKIP ();
        yych = YYPEEK ();
        switch (yych) {
        case 'c':    goto yy27;
        default:    goto yy13;
        }
yy27:
        YYSKIP ();
        status = action_line144(i, keys, input, token, &cursor, 1);
        continue;

    }
    if (status == 0) {
        if (cursor != eof) {
            status = 1;
            const long pos = token - input;
            fprintf(stderr, "error: lex_line144: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count) {
            status = 1;
            fprintf(stderr, "error: lex_line144: unused keys left after %u iterations\n", i);
        }
    }

end:
    free(input);
    free(keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYBACKUP
#undef YYRESTORE
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned char
#define YYKEYTYPE unsigned char
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYBACKUP() marker = cursor
#define YYRESTORE() cursor = marker
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line247
    ( unsigned int i
    , const YYKEYTYPE *keys
    , const YYCTYPE *start
    , const YYCTYPE *token
    , const YYCTYPE **cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 255) {
        fprintf
            ( stderr
            , "warning: lex_line247: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp) {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    } else {
        fprintf
            ( stderr
            , "error: lex_line247: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line247()
{
    const size_t padding = 5; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE *input = NULL;
    YYKEYTYPE *keys = NULL;
    const YYCTYPE *cursor = NULL;
    const YYCTYPE *limit = NULL;
    const YYCTYPE *token = NULL;
    const YYCTYPE *eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("scanner.S.c.line247.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL) {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("scanner.S.c.line247.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL) {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i) {
        token = cursor;
        const YYCTYPE *marker = NULL;
        YYCTYPE yych;
        unsigned int yyaccept = 0;

        if (YYLESSTHAN (5)) YYFILL(5);
        yych = YYPEEK ();
        switch (yych) {
        case '\t':
        case ' ':    goto yy50;
        case '\n':    goto yy52;
        case '\r':    goto yy54;
        case '"':    goto yy37;
        case '\'':    goto yy39;
        case '(':
        case ')':
        case ';':
        case '=':
        case '\\':
        case '|':    goto yy43;
        case '*':    goto yy35;
        case '+':
        case '?':    goto yy44;
        case '.':    goto yy48;
        case '/':    goto yy33;
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z':    goto yy47;
        case '[':    goto yy41;
        case 'r':    goto yy45;
        case '{':    goto yy31;
        default:    goto yy56;
        }
yy31:
        yyaccept = 0;
        YYSKIP ();
        YYBACKUP ();
        yych = YYPEEK ();
        switch (yych) {
        case ',':    goto yy97;
        case '0':    goto yy94;
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':    goto yy95;
        default:    goto yy32;
        }
yy32:
        status = action_line247(i, keys, input, token, &cursor, 0);
        continue;
yy33:
        YYSKIP ();
        switch ((yych = YYPEEK ())) {
        case '*':    goto yy92;
        default:    goto yy34;
        }
yy34:
        status = action_line247(i, keys, input, token, &cursor, 10);
        continue;
yy35:
        YYSKIP ();
        switch ((yych = YYPEEK ())) {
        case '/':    goto yy90;
        default:    goto yy36;
        }
yy36:
        status = action_line247(i, keys, input, token, &cursor, 11);
        continue;
yy37:
        yyaccept = 1;
        YYSKIP ();
        YYBACKUP ();
        yych = YYPEEK ();
        switch (yych) {
        case '\n':    goto yy38;
        default:    goto yy86;
        }
yy38:
        status = action_line247(i, keys, input, token, &cursor, 5);
        continue;
yy39:
        yyaccept = 2;
        YYSKIP ();
        YYBACKUP ();
        yych = YYPEEK ();
        switch (yych) {
        case '\n':    goto yy40;
        default:    goto yy81;
        }
yy40:
        status = action_line247(i, keys, input, token, &cursor, 6);
        continue;
yy41:
        yyaccept = 3;
        YYSKIP ();
        YYBACKUP ();
        yych = YYPEEK ();
        switch (yych) {
        case '\n':    goto yy42;
        case '^':    goto yy72;
        default:    goto yy71;
        }
yy42:
        status = action_line247(i, keys, input, token, &cursor, 9);
        continue;
yy43:
        YYSKIP ();
        yych = YYPEEK ();
        goto yy34;
yy44:
        YYSKIP ();
        yych = YYPEEK ();
        goto yy36;
yy45:
        YYSKIP ();
        switch ((yych = YYPEEK ())) {
        case 'e':    goto yy62;
        default:    goto yy61;
        }
yy46:
        status = action_line247(i, keys, input, token, &cursor, 18);
        continue;
yy47:
        YYSKIP ();
        yych = YYPEEK ();
        goto yy61;
yy48:
        YYSKIP ();
        status = action_line247(i, keys, input, token, &cursor, 19);
        continue;
yy50:
        YYSKIP ();
        yych = YYPEEK ();
        goto yy59;
yy51:
        status = action_line247(i, keys, input, token, &cursor, 20);
        continue;
yy52:
        YYSKIP ();
yy53:
        status = action_line247(i, keys, input, token, &cursor, 21);
        continue;
yy54:
        YYSKIP ();
        switch ((yych = YYPEEK ())) {
        case '\n':    goto yy57;
        default:    goto yy55;
        }
yy55:
        status = action_line247(i, keys, input, token, &cursor, 22);
        continue;
yy56:
        YYSKIP ();
        yych = YYPEEK ();
        goto yy55;
yy57:
        YYSKIP ();
        yych = YYPEEK ();
        goto yy53;
yy58:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
yy59:
        switch (yych) {
        case '\t':
        case ' ':    goto yy58;
        default:    goto yy51;
        }
yy60:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
yy61:
        switch (yych) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z':    goto yy60;
        default:    goto yy46;
        }
yy62:
        YYSKIP ();
        yych = YYPEEK ();
        switch (yych) {
        case '2':    goto yy63;
        default:    goto yy61;
        }
yy63:
        YYSKIP ();
        yych = YYPEEK ();
        switch (yych) {
        case 'c':    goto yy64;
        default:    goto yy61;
        }
yy64:
        yyaccept = 4;
        YYSKIP ();
        YYBACKUP ();
        yych = YYPEEK ();
        switch (yych) {
        case ':':    goto yy65;
        default:    goto yy61;
        }
yy65:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        switch (yych) {
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z':    goto yy67;
        default:    goto yy66;
        }
yy66:
        YYRESTORE ();
        switch (yyaccept) {
        case 0: 	goto yy32;
        case 1: 	goto yy38;
        case 2: 	goto yy40;
        case 3: 	goto yy42;
        case 4: 	goto yy46;
        case 5: 	goto yy69;
        default:	goto yy98;
        }
yy67:
        yyaccept = 5;
        YYSKIP ();
        YYBACKUP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        switch (yych) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case '_':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z':    goto yy67;
        case ':':    goto yy65;
        default:    goto yy69;
        }
yy69:
        status = action_line247(i, keys, input, token, &cursor, 17);
        continue;
yy70:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
yy71:
        switch (yych) {
        case '\n':    goto yy66;
        case '\\':    goto yy74;
        case ']':    goto yy75;
        default:    goto yy70;
        }
yy72:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        switch (yych) {
        case '\n':    goto yy66;
        case '\\':    goto yy77;
        case ']':    goto yy78;
        default:    goto yy72;
        }
yy74:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        switch (yych) {
        case '\n':    goto yy66;
        default:    goto yy70;
        }
yy75:
        YYSKIP ();
        status = action_line247(i, keys, input, token, &cursor, 8);
        continue;
yy77:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        switch (yych) {
        case '\n':    goto yy66;
        default:    goto yy72;
        }
yy78:
        YYSKIP ();
        status = action_line247(i, keys, input, token, &cursor, 7);
        continue;
yy80:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
yy81:
        switch (yych) {
        case '\n':    goto yy66;
        case '\'':    goto yy83;
        case '\\':    goto yy82;
        default:    goto yy80;
        }
yy82:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        switch (yych) {
        case '\n':    goto yy66;
        default:    goto yy80;
        }
yy83:
        YYSKIP ();
        status = action_line247(i, keys, input, token, &cursor, 4);
        continue;
yy85:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
yy86:
        switch (yych) {
        case '\n':    goto yy66;
        case '"':    goto yy88;
        case '\\':    goto yy87;
        default:    goto yy85;
        }
yy87:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        switch (yych) {
        case '\n':    goto yy66;
        default:    goto yy85;
        }
yy88:
        YYSKIP ();
        status = action_line247(i, keys, input, token, &cursor, 3);
        continue;
yy90:
        YYSKIP ();
        status = action_line247(i, keys, input, token, &cursor, 2);
        continue;
yy92:
        YYSKIP ();
        status = action_line247(i, keys, input, token, &cursor, 1);
        continue;
yy94:
        YYSKIP ();
        yych = YYPEEK ();
        switch (yych) {
        case ',':    goto yy108;
        default:    goto yy96;
        }
yy95:
        YYSKIP ();
        if (YYLESSTHAN (2)) YYFILL(2);
        yych = YYPEEK ();
yy96:
        switch (yych) {
        case ',':    goto yy101;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':    goto yy95;
        case '}':    goto yy99;
        default:    goto yy66;
        }
yy97:
        YYSKIP ();
yy98:
        status = action_line247(i, keys, input, token, &cursor, 16);
        continue;
yy99:
        YYSKIP ();
        status = action_line247(i, keys, input, token, &cursor, 13);
        continue;
yy101:
        yyaccept = 6;
        YYSKIP ();
        YYBACKUP ();
        yych = YYPEEK ();
        switch (yych) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':    goto yy104;
        case '}':    goto yy102;
        default:    goto yy98;
        }
yy102:
        YYSKIP ();
        status = action_line247(i, keys, input, token, &cursor, 15);
        continue;
yy104:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        switch (yych) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':    goto yy104;
        case '}':    goto yy106;
        default:    goto yy66;
        }
yy106:
        YYSKIP ();
        status = action_line247(i, keys, input, token, &cursor, 14);
        continue;
yy108:
        yyaccept = 6;
        YYSKIP ();
        YYBACKUP ();
        yych = YYPEEK ();
        switch (yych) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':    goto yy104;
        case '}':    goto yy109;
        default:    goto yy98;
        }
yy109:
        YYSKIP ();
        status = action_line247(i, keys, input, token, &cursor, 12);
        continue;

    }
    if (status == 0) {
        if (cursor != eof) {
            status = 1;
            const long pos = token - input;
            fprintf(stderr, "error: lex_line247: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count) {
            status = 1;
            fprintf(stderr, "error: lex_line247: unused keys left after %u iterations\n", i);
        }
    }

end:
    free(input);
    free(keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYBACKUP
#undef YYRESTORE
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned char
#define YYKEYTYPE unsigned char
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYBACKUP() marker = cursor
#define YYRESTORE() cursor = marker
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line264
    ( unsigned int i
    , const YYKEYTYPE *keys
    , const YYCTYPE *start
    , const YYCTYPE *token
    , const YYCTYPE **cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 255) {
        fprintf
            ( stderr
            , "warning: lex_line264: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp) {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    } else {
        fprintf
            ( stderr
            , "error: lex_line264: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line264()
{
    const size_t padding = 2; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE *input = NULL;
    YYKEYTYPE *keys = NULL;
    const YYCTYPE *cursor = NULL;
    const YYCTYPE *limit = NULL;
    const YYCTYPE *token = NULL;
    const YYCTYPE *eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("scanner.S.c.line264.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL) {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("scanner.S.c.line264.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL) {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i) {
        token = cursor;
        const YYCTYPE *marker = NULL;
        YYCTYPE yych;

        if (YYLESSTHAN (2)) YYFILL(2);
        yych = YYPEEK ();
        switch (yych) {
        case '\n':    goto yy117;
        case '"':    goto yy121;
        case '\'':    goto yy122;
        case '{':    goto yy115;
        case '}':    goto yy113;
        default:    goto yy119;
        }
yy113:
        YYSKIP ();
        status = action_line264(i, keys, input, token, &cursor, 0);
        continue;
yy115:
        YYSKIP ();
        status = action_line264(i, keys, input, token, &cursor, 1);
        continue;
yy117:
        YYSKIP ();
        status = action_line264(i, keys, input, token, &cursor, 2);
        continue;
yy119:
        YYSKIP ();
yy120:
        status = action_line264(i, keys, input, token, &cursor, 3);
        continue;
yy121:
        YYSKIP ();
        YYBACKUP ();
        yych = YYPEEK ();
        switch (yych) {
        case '\n':    goto yy120;
        default:    goto yy128;
        }
yy122:
        YYSKIP ();
        YYBACKUP ();
        yych = YYPEEK ();
        switch (yych) {
        case '\n':    goto yy120;
        default:    goto yy124;
        }
yy123:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
yy124:
        switch (yych) {
        case '\n':    goto yy125;
        case '\'':    goto yy119;
        case '\\':    goto yy126;
        default:    goto yy123;
        }
yy125:
        YYRESTORE ();
        goto yy120;
yy126:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        switch (yych) {
        case '\n':    goto yy125;
        default:    goto yy123;
        }
yy127:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
yy128:
        switch (yych) {
        case '\n':    goto yy125;
        case '"':    goto yy119;
        case '\\':    goto yy129;
        default:    goto yy127;
        }
yy129:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        switch (yych) {
        case '\n':    goto yy125;
        default:    goto yy127;
        }

    }
    if (status == 0) {
        if (cursor != eof) {
            status = 1;
            const long pos = token - input;
            fprintf(stderr, "error: lex_line264: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count) {
            status = 1;
            fprintf(stderr, "error: lex_line264: unused keys left after %u iterations\n", i);
        }
    }

end:
    free(input);
    free(keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYBACKUP
#undef YYRESTORE
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned char
#define YYKEYTYPE unsigned char
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line281
    ( unsigned int i
    , const YYKEYTYPE *keys
    , const YYCTYPE *start
    , const YYCTYPE *token
    , const YYCTYPE **cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 255) {
        fprintf
            ( stderr
            , "warning: lex_line281: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp) {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    } else {
        fprintf
            ( stderr
            , "error: lex_line281: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line281()
{
    const size_t padding = 2; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE *input = NULL;
    YYKEYTYPE *keys = NULL;
    const YYCTYPE *cursor = NULL;
    const YYCTYPE *limit = NULL;
    const YYCTYPE *token = NULL;
    const YYCTYPE *eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("scanner.S.c.line281.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL) {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("scanner.S.c.line281.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL) {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i) {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (2)) YYFILL(2);
        yych = YYPEEK ();
        switch (yych) {
        case '\n':    goto yy135;
        case '*':    goto yy132;
        case '/':    goto yy134;
        default:    goto yy137;
        }
yy132:
        YYSKIP ();
        switch ((yych = YYPEEK ())) {
        case '/':    goto yy140;
        default:    goto yy133;
        }
yy133:
        status = action_line281(i, keys, input, token, &cursor, 3);
        continue;
yy134:
        YYSKIP ();
        yych = YYPEEK ();
        switch (yych) {
        case '*':    goto yy138;
        default:    goto yy133;
        }
yy135:
        YYSKIP ();
        status = action_line281(i, keys, input, token, &cursor, 2);
        continue;
yy137:
        YYSKIP ();
        yych = YYPEEK ();
        goto yy133;
yy138:
        YYSKIP ();
        status = action_line281(i, keys, input, token, &cursor, 1);
        continue;
yy140:
        YYSKIP ();
        status = action_line281(i, keys, input, token, &cursor, 0);
        continue;

    }
    if (status == 0) {
        if (cursor != eof) {
            status = 1;
            const long pos = token - input;
            fprintf(stderr, "error: lex_line281: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count) {
            status = 1;
            fprintf(stderr, "error: lex_line281: unused keys left after %u iterations\n", i);
        }
    }

end:
    free(input);
    free(keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned char
#define YYKEYTYPE unsigned char
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line291
    ( unsigned int i
    , const YYKEYTYPE *keys
    , const YYCTYPE *start
    , const YYCTYPE *token
    , const YYCTYPE **cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 255) {
        fprintf
            ( stderr
            , "warning: lex_line291: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp) {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    } else {
        fprintf
            ( stderr
            , "error: lex_line291: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line291()
{
    const size_t padding = 2; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE *input = NULL;
    YYKEYTYPE *keys = NULL;
    const YYCTYPE *cursor = NULL;
    const YYCTYPE *limit = NULL;
    const YYCTYPE *token = NULL;
    const YYCTYPE *eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("scanner.S.c.line291.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL) {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("scanner.S.c.line291.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL) {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i) {
        token = cursor;
        YYCTYPE yych;

        if (YYLESSTHAN (2)) YYFILL(2);
        yych = YYPEEK ();
        switch (yych) {
        case '\t':
        case ' ':    goto yy144;
        case '=':    goto yy146;
        default:    goto yy148;
        }
yy144:
        YYSKIP ();
        yych = YYPEEK ();
        goto yy153;
yy145:
        status = action_line291(i, keys, input, token, &cursor, 0);
        continue;
yy146:
        YYSKIP ();
        yych = YYPEEK ();
        goto yy151;
yy147:
        status = action_line291(i, keys, input, token, &cursor, 1);
        continue;
yy148:
        YYSKIP ();
        status = action_line291(i, keys, input, token, &cursor, 2);
        continue;
yy150:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
yy151:
        switch (yych) {
        case '\t':
        case ' ':    goto yy150;
        default:    goto yy147;
        }
yy152:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
yy153:
        switch (yych) {
        case '\t':
        case ' ':    goto yy152;
        default:    goto yy145;
        }

    }
    if (status == 0) {
        if (cursor != eof) {
            status = 1;
            const long pos = token - input;
            fprintf(stderr, "error: lex_line291: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count) {
            status = 1;
            fprintf(stderr, "error: lex_line291: unused keys left after %u iterations\n", i);
        }
    }

end:
    free(input);
    free(keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYLESSTHAN
#undef YYFILL

#define YYCTYPE unsigned char
#define YYKEYTYPE unsigned char
#define YYPEEK() *cursor
#define YYSKIP() ++cursor
#define YYBACKUP() marker = cursor
#define YYRESTORE() cursor = marker
#define YYLESSTHAN(n) (limit - cursor) < n
#define YYFILL(n) { break; }

static int action_line305
    ( unsigned int i
    , const YYKEYTYPE *keys
    , const YYCTYPE *start
    , const YYCTYPE *token
    , const YYCTYPE **cursor
    , YYKEYTYPE rule_act
    )
{
    const long pos = token - start;
    const long len_act = *cursor - token;
    const long len_exp = (long) keys [3 * i + 1];
    const YYKEYTYPE rule_exp = keys [3 * i + 2];
    if (rule_exp == 255) {
        fprintf
            ( stderr
            , "warning: lex_line305: control flow is undefined for input"
                " at position %ld, rerun re2c with '-W'\n"
            , pos
            );
    }
    if (len_act == len_exp && rule_act == rule_exp) {
        const YYKEYTYPE offset = keys[3 * i];
        *cursor = token + offset;
        return 0;
    } else {
        fprintf
            ( stderr
            , "error: lex_line305: at position %ld (iteration %u):\n"
                "\texpected: match length %ld, rule %u\n"
                "\tactual:   match length %ld, rule %u\n"
            , pos
            , i
            , len_exp
            , rule_exp
            , len_act
            , rule_act
            );
        return 1;
    }
}

int lex_line305()
{
    const size_t padding = 2; /* YYMAXFILL */
    int status = 0;
    size_t input_len = 0;
    size_t keys_count = 0;
    YYCTYPE *input = NULL;
    YYKEYTYPE *keys = NULL;
    const YYCTYPE *cursor = NULL;
    const YYCTYPE *limit = NULL;
    const YYCTYPE *token = NULL;
    const YYCTYPE *eof = NULL;
    unsigned int i = 0;

    input = (YYCTYPE *) read_file
        ("scanner.S.c.line305.input"
        , sizeof (YYCTYPE)
        , padding
        , &input_len
        );
    if (input == NULL) {
        status = 1;
        goto end;
    }

    keys = (YYKEYTYPE *) read_file
        ("scanner.S.c.line305.keys"
        , 3 * sizeof (YYKEYTYPE)
        , 0
        , &keys_count
        );
    if (keys == NULL) {
        status = 1;
        goto end;
    }

    cursor = input;
    limit = input + input_len + padding;
    eof = input + input_len;

    for (i = 0; status == 0 && i < keys_count; ++i) {
        token = cursor;
        const YYCTYPE *marker = NULL;
        YYCTYPE yych;

        if (YYLESSTHAN (2)) YYFILL(2);
        yych = YYPEEK ();
        switch (yych) {
        case '\t':
        case '\n':
        case '\r':
        case ' ':
        case ';':    goto yy156;
        case '"':    goto yy164;
        case '\'':    goto yy166;
        case '-':    goto yy159;
        case '0':    goto yy157;
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':    goto yy160;
        default:    goto yy162;
        }
yy156:
        status = action_line305(i, keys, input, token, &cursor, 1);
        continue;
yy157:
        YYSKIP ();
        switch ((yych = YYPEEK ())) {
        case '\t':
        case '\n':
        case '\r':
        case ' ':
        case ';':    goto yy158;
        default:    goto yy162;
        }
yy158:
        status = action_line305(i, keys, input, token, &cursor, 0);
        continue;
yy159:
        YYSKIP ();
        yych = YYPEEK ();
        switch (yych) {
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':    goto yy160;
        default:    goto yy163;
        }
yy160:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        switch (yych) {
        case '\t':
        case '\n':
        case '\r':
        case ' ':
        case ';':    goto yy158;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':    goto yy160;
        default:    goto yy162;
        }
yy162:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
yy163:
        switch (yych) {
        case '\t':
        case '\n':
        case '\r':
        case ' ':
        case ';':    goto yy156;
        default:    goto yy162;
        }
yy164:
        YYSKIP ();
        YYBACKUP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        switch (yych) {
        case '\t':
        case '\r':
        case ' ':
        case ';':    goto yy174;
        case '\n':    goto yy156;
        case '"':    goto yy162;
        case '\\':    goto yy176;
        default:    goto yy164;
        }
yy166:
        YYSKIP ();
        YYBACKUP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        switch (yych) {
        case '\t':
        case '\r':
        case ' ':
        case ';':    goto yy168;
        case '\n':    goto yy156;
        case '\'':    goto yy162;
        case '\\':    goto yy171;
        default:    goto yy166;
        }
yy168:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        switch (yych) {
        case '\n':    goto yy170;
        case '\'':    goto yy172;
        case '\\':    goto yy173;
        default:    goto yy168;
        }
yy170:
        YYRESTORE ();
        goto yy156;
yy171:
        YYSKIP ();
        YYBACKUP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        switch (yych) {
        case '\t':
        case '\r':
        case ' ':
        case ';':    goto yy168;
        case '\n':    goto yy156;
        default:    goto yy166;
        }
yy172:
        YYSKIP ();
        yych = YYPEEK ();
        goto yy156;
yy173:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        switch (yych) {
        case '\n':    goto yy170;
        default:    goto yy168;
        }
yy174:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        switch (yych) {
        case '\n':    goto yy170;
        case '"':    goto yy172;
        case '\\':    goto yy177;
        default:    goto yy174;
        }
yy176:
        YYSKIP ();
        YYBACKUP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        switch (yych) {
        case '\t':
        case '\r':
        case ' ':
        case ';':    goto yy174;
        case '\n':    goto yy156;
        default:    goto yy164;
        }
yy177:
        YYSKIP ();
        if (YYLESSTHAN (1)) YYFILL(1);
        yych = YYPEEK ();
        switch (yych) {
        case '\n':    goto yy170;
        default:    goto yy174;
        }

    }
    if (status == 0) {
        if (cursor != eof) {
            status = 1;
            const long pos = token - input;
            fprintf(stderr, "error: lex_line305: unused input strings left at position %ld\n", pos);
        }
        if (i != keys_count) {
            status = 1;
            fprintf(stderr, "error: lex_line305: unused keys left after %u iterations\n", i);
        }
    }

end:
    free(input);
    free(keys);

    return status;
}

#undef YYCTYPE
#undef YYKEYTYPE
#undef YYPEEK
#undef YYSKIP
#undef YYBACKUP
#undef YYRESTORE
#undef YYLESSTHAN
#undef YYFILL

int main()
{
    if(lex_line144() != 0) {
        return 1;
    }
    if(lex_line247() != 0) {
        return 1;
    }
    if(lex_line264() != 0) {
        return 1;
    }
    if(lex_line281() != 0) {
        return 1;
    }
    if(lex_line291() != 0) {
        return 1;
    }
    if(lex_line305() != 0) {
        return 1;
    }
    return 0;
}
/*!max:re2c/*!max:re2 /*!max:re2b/*!max:re2d/*!max:re2ÿ/*!max:re /*!max:re1/*!max:re3/*!max:reÿ/*!max:r /*!max:rd/*!max:rf/*!max:rÿ/*!max: /*!max:q/*!max:s/*!max:ÿ/*!max /*!max9/*!max;/*!maxÿ/*!ma /*!maw/*!may/*!maÿ/*!m /*!m`/*!mb/*!mÿ/*!re2c/*!re2 /*!re2b/*!re2d/*!re2ÿ/*!re /*!re1/*!re3/*!reÿ/*!r /*!rd/*!rf/*!rÿ/*! /*!l/*!n/*!q/*!s/*!ÿ/* /* /*"/*ÿ/ /)/+/ÿ*/* *.*0*ÿ
 	)+.0ÿ



				 {000}{099}{000,}{099,}{000,00}{099,99}{000,00 {099,99/{000,00:{099,99|{000,00~{099,99ÿ{000,0}{099,9}{000,0 {099,9/{000,0:{099,9|{000,0~{099,9ÿ{000, {099,/{000,:{099,|{000,~{099,ÿ{000 {099+{000-{099/{000:{099|{000~{099ÿ{00}{09}{00,}{09,}{00 {09+{00-{09/{00:{09|{00~{09ÿ{0}{0,0}{0,9}{0,}{0, {0,/{0,:{0,|{0,~{0,ÿ{0 {0+{0-{0/{0:{0|{0~{0ÿ{1}{9}{,{ {+{-{/{:{ÿ/*/ /)/+/ÿ*/* *.*0*ÿ"  \
"		\
"\
"!!\
"##\
"[[\
"]]\
"ÿÿ\
"  ""		""""!!""##""[[""]]""ÿÿ""  
"		
"
"!!
"##
"[[
"]]
"ÿÿ
" \
"	\
"\
"!\
"#\
"[\
"]\
"ÿ\
" ""	""""!""#""[""]""ÿ"" 
"	
"
"!
"#
"[
"]
"ÿ
"\
"""
'  \
'		\
'\
'&&\
'((\
'[[\
']]\
'ÿÿ\
'  ''		''''&&''((''[['']]''ÿÿ''  
'		
'
'&&
'((
'[[
']]
'ÿÿ
' \
'	\
'\
'&\
'(\
'[\
']\
'ÿ\
' ''	''''&''(''['']''ÿ'' 
'	
'
'&
'(
'[
']
'ÿ
'\
'''
[  \
[		\
[\
[[[\
[_^\
[ÿÿ\
[  ][		][][[[][_^][ÿÿ][  
[		
[
[[[
[_^
[ÿÿ
[ \
[	\
[\
[[\
[_\
[ÿ\
[ ][	][][[][_][ÿ][ 
[	
[
[[
[_
[ÿ
[^ \
[^	\
[^\
[^[\
[^^\
[^ÿ\
[^ ][^	][^][^[][^^][^ÿ][^ 
[^	
[^
[^[
[^^
[^ÿ
[^\
[^][^
[\
[][
();=\|+?r00 r99/rAA:rZZ@raa[rdz`rf0{rz9ÿr0 r9/rA:rZ@ra[rd`rf{rzÿre0 re1 re3 re9 reA reZ rea rez re20 re29 re2A re2Z re2a re2b re2d re2z re2c0 re2c9 re2cA re2cZ re2ca re2cz re2c:A:A re2c:Z:Z/re2c:a:a;re2c:z:z@re2c:A:A[re2c:Z:Z^re2c:a:a`re2c:z:z{re2c:A:Aÿre2c:A: re2c:Z:@re2c:a:[re2c:z:`re2c:A:{re2c:Z:ÿre2c:A0 re2c:Z9 re2c:aA re2c:zZ re2c:A_ re2c:Za re2c:az re2c:A re2c:Z/re2c:a;re2c:z@re2c:A[re2c:Z^re2c:a`re2c:z{re2c:Aÿre2c: re2c:@re2c:[re2c:`re2c:{re2c:ÿre2c re2c/re2c;re2c@re2c[re2c`re2c{re2cÿre2 re2/re2:re2@re2[re2`re2{re2ÿre re/re:re@re[re`re{reÿr r/r:r@r[r`r{rÿA0 Z9 aA qZ sa zz A Z/a:q@s[z`A{Zÿ.			    			
   			!   ÿ		   		
  		!  ÿ	  	
 	! ÿ

 	ÿ !#&,-0:<>@]`}ÿ                              



																																								





									}{
 	!#&(z|~ÿ""" ""	""""!""#""[""]""ÿ""  ""		""""!!""##""[[""]]""ÿÿ"" \ ""	\	""\""!\ÿ""#\ ""[\	""]\""ÿ\ÿ"" \
"	\
"\
"!\
"#\
"[\
"]\
"ÿ\
" 
"	
"
"!
"#
"[
"]
"ÿ
"\ ""
''' ''	''''&''(''['']''ÿ''  ''		''''&&''((''[['']]''ÿÿ'' \ ''	\	''\''&\ÿ''(\ ''[\	'']\''ÿ\ÿ'' \
'	\
'\
'&\
'(\
'[\
']\
'ÿ\
' 
'	
'
'&
'(
'[
']
'ÿ
'\ ''
 */* *.*0*ÿ/*/ /)/+/ÿ
 	)+.0ÿ 			    			
   			!   ÿ		   		
  		!  ÿ	  	
 	! ÿ=		 =  =		
=  =		!=  ÿ=	 = =	
= =	!= ÿ= ==
==!=ÿ 
!<>ÿ                  0  	0
00 0;0	0!!
0::0<< 0ÿÿ;0 	0
00 0;0	0!
0:0< 0ÿ;0	0
00 0;-10 	-99	-10	-99	-10	-99	-10!	-99/	-10:	-99<	-10ÿ	-10	-99
-10-99 -10;-1 	-9	-1	-9	-1	-9	-1!	-9/	-1:	-9<	-1ÿ	-1	-9
-1-9 -1;- 	-	-	-	-	-	-!	-0	-:	-<	-ÿ	-	-
-- -;1 	9 	 						!	#	&	(	,	.	/	:	<	ÿ	""	" "	""	""	""	""	""	"!"	"#"	":"	"<"	"["	"]"	"ÿ"	"	"""" "";""	 ""	"" "";!""	#""["" ]"";ÿ""	\ ""\	"" \"";\ÿ""	\
"\
" \
";\
"	
"
" 
";
"\ "	"\"	"\"	"\"	"\"	"\"	"\!"	"\:"	"\<"	"\ÿ"	"\	""\""\ ""\;""\
"
''	' '	''	''	''	''	''	'!'	'&'	'('	':'	'<'	'['	']'	'ÿ'	'	 ''	'' '';&''	(''['' ]'';ÿ''	 \ ''	\	'' \'';&\ÿ''	(\ ''[\	'' ]\'';ÿ\ÿ''	 \
'	\
' \
';&\
'	(\
'[\
' ]\
';ÿ\
'	 
'	
' 
';&
'	(
'[
' ]
';ÿ
'	'''' '';''	\ ''\ '' \ '';\ ''	
'
' 
';
'\ '	'\'	'\'	'\'	'\'	'\'	'\!'	'\:'	'\<'	'\ÿ'	'\	''\''\ ''\;''\
'
	
 ;                    re2c: warning: line 300: rule matches empty string [-Wmatch-empty-string]
