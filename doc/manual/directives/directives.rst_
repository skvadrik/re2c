Below is the list of re2c directives (syntactic constructs that mark the
beginning and end of the code that should be processed by re2c). Named blocks
were added in re2c version 2.2. They are exactly the same as unnamed blocks,
except that the name can be used to reference a block in other parts of the
program. More information on each directive can be found in the related
sections.

``/*!re2c[:<name>] ... */``
    A global re2c block with an optional name. The block may contain named
    definitions, configurations and rules in any order. Named definitions and
    configurations are defined in the global scope, so they are inherited by
    subsequent blocks. The code for a global block is generated at the point
    where the block is specified.

``/*!local:re2c[:<name>] ... */``
    A local re2c block with an optional name. Unlike global blocks, definitions
    and configurations inside of a local block are not added into the global
    scope. In all other respects local blocks are the same as global blocks.

``/*!rules:re2c[:<name>] ... */``
    A reusable block with an optional name. Rules blocks have the same structure
    as local or global blocks, but they do not produce any code and they can be
    reused multiple times in other blocks with the help of a ``!use:<name>;``
    directive or a ``/*!use:re2c[:<name>] ... */`` block. A rules block on its
    own does not add any definitions into the global scope. The code for it is
    generated at the point of use. Prior to re2c version 2.2 rules blocks
    required ``-r --reusable`` option.

``/*!use:re2c[:<name>] ... */``
    A use block that references a previously defined rules block. If the name is
    specified, re2c looks for a rules blocks with this name. Otherwise the most
    recent rules block is used (either a named or an unnamed one). A use block
    can add definitions, configurations and rules of its own, which are added to
    those of the referenced rules block. Prior to re2c version 2.2 use blocks
    required ``-r --reusable`` option.

``!use:<name>;``
    An in-block use directive that merges a previously defined rules block with
    the specified name into the current block. Named definitions, configurations
    and rules of the referenced block are added to the current ones. Conflicts
    between overlapping rules and configurations are resolved in the usual way:
    the first rule takes priority, and the latest configuration overrides the
    preceding ones. One exception is the special rules ``*``, ``$`` and ``<!>``
    for which a block-local definition always takes priority. A use directive
    can be placed anywhere inside of a block, and multiple use directives are
    allowed.

``/*!max:re2c[:<name1>[:<name2>...]] ... */``
    A directive that generates ``YYMAXFILL`` definition.
    An optional list of block names specifies which blocks should be included
    when computing ``YYMAXFILL`` value (if the list is empty, all blocks are
    included).
    By default the generated code is a macro-definition for C
    (``#define YYMAXFILL <n>``), or a global variable for Go
    (``var YYMAXFILL int = <n>``). It can be customized with an optional
    configuration ``format`` that specifies a template string where ``@@{max}``
    (or ``@@`` for short) is replaced with the numeric value of ``YYMAXFILL``.

``/*!maxnmatch:re2c[:<name1>[:<name2>...]] ... */``
    A directive that generates ``YYMAXNMATCH`` definition (it requires
    ``-P --posix-captures`` option).
    An optional list of block names specifies which blocks should be included
    when computing ``YYMAXNMATCH`` value (if the list is empty, all blocks are
    included).
    By default the generated code is a macro-definition for C
    (``#define YYMAXNMATCH <n>``), or a global variable for Go
    (``var YYMAXNMATCH int = <n>``). It can be customized with an optional
    configuration ``format`` that specifies a template string where ``@@{max}``
    (or ``@@`` for short) is replaced with the numeric value of ``YYMAXNMATCH``.

``/*!stags:re2c[:<name1>[:<name2>...]] ... */``, ``/*!mtags:re2c[:<name1>[:<name2>...]] ... */``
    Directives that specify a template piece of code that is expanded for each
    s-tag/m-tag variable generated by re2c.
    An optional list of block names specifies which blocks should be included
    when computing the set of tag variables (if the list is empty, all blocks
    are included).
    There are two optional configurations: ``format`` and ``separator``.
    Configuration ``format`` specifies a template string where ``@@(tag}`` (or
    ``@@`` for short) is replaced with the name of each tag variable.
    Configuration ``separator`` specifies a piece of code used to join the
    generated ``format`` pieces for different tag variables.

``/*!getstate:re2c[:<name1>[:<name2>...]] ... */``
    A directive that generates conditional dispatch on the lexer state (it
    requires ``-f --storable-state`` option).
    An optional list of block names specifies which blocks should be included in
    the state dispatch. The default transition goes to the start label of the
    first block on the list. If the list is empty, all blocks are included, and
    the default transition goes to the first block in the file that has a start
    label.

``/*!types:re2c[:<name1>[:<name2>...]] ... */``
    A directive that generates condition enumeration (it requires
    ``-c --conditions`` option).
    An optional list of block names specifies which blocks should be included
    when computing the set of conditions (if the list is empty, all blocks are
    included).
    By default the generated code is an enumeration ``YYCONDTYPE``. It can be
    customized with optional configurations ``format`` and ``separator``.
    Configuration ``format`` specifies a template string where ``@@(cond}`` (or
    ``@@`` for short) is replaced with the name of each condition, and
    ``@@{num}`` is replaced with a numeric index of that condition.
    Configuration ``separator`` specifies a piece of code used to join the
    generated ``format`` pieces for different conditions.

``/*!include:re2c <file> */``
    This directive allows one to include ``<file>``, which must be a double-quoted
    file path. The contents of the file are literally substituted in place of
    the directive, in the same way as ``#include`` works in C/C++. This
    directive can be used together with the ``--depfile`` option to generate
    build system dependencies on the included files.

``!include <file>;``
    This directive is the same as ``/*!include:re2c <file> */``, except that it
    should be used inside of a re2c block.

``/*!header:re2c:on*/``
    This directive marks the start of header file. Everything after it and up to
    the following ``/*!header:re2c:off*/`` directive is processed by re2c and
    written to the header file specified with ``-t --type-header`` option.

``/*!header:re2c:off*/``
    This directive marks the end of header file started with
    ``/*!header:re2c:on*/``.

``/*!ignore:re2c ... */``
    A block which contents are ignored and removed from the output file.

``%{ ... %}``
    A global re2c block in ``-F --flex-support`` mode. This is deprecated and
    exists for backward compatibility.
