%{

#include <stdio.h>
#include <stdlib.h>

#include "src/util/c99_stdint.h"
#include "src/parse/ast.h"
#include "lib/lex.h"

// disable certain GCC and/or Clang warnings,  as we have no control over
// autogenerated code (Clang also understands '#pragma GCC')
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpragmas"
#pragma GCC diagnostic ignored "-Wconversion"
#pragma GCC diagnostic ignored "-Wsign-conversion"
#pragma GCC diagnostic ignored "-Wunused-macros"
#pragma GCC diagnostic ignored "-Wmissing-variable-declarations"
#pragma GCC diagnostic ignored "-Wunreachable-code"
#pragma GCC diagnostic ignored "-Wunreachable-code-break"

using namespace re2c;

extern "C" {

int yylex(const char *&pattern);
void yyerror(const char *pattern, const char*) RE2C_ATTR((noreturn));

} // extern "C"

%}

%lex-param   {const char *&pattern}
%parse-param {const char *&pattern}

%start regexp

%union {
    const re2c::AST *regexp;
    re2c::ASTBounds bounds;
};

%token TOKEN_COUNT
%token TOKEN_ERROR
%token TOKEN_REGEXP

%type <regexp> TOKEN_REGEXP regexp expr term factor primary
%type <bounds> TOKEN_COUNT

%%

regexp: expr { regexp = $$; };

expr
: term
| expr '|' term { $$ = ast_alt($1, $3); }
;

term
: factor
| factor term { $$ = ast_cat($1, $2); } // in POSIX concatenation is right-associative
;

factor
: primary
| primary '*'         { $$ = ast_iter($1, 0, AST::MANY); }
| primary '+'         { $$ = ast_iter($1, 1, AST::MANY); }
| primary '?'         { $$ = ast_iter($1, 0, 1); }
| primary TOKEN_COUNT { $$ = ast_iter($1, $2.min, $2.max); }
;

primary
: TOKEN_REGEXP
| '(' ')'      { $$ = ast_cap(ast_nil(NOWHERE)); }
| '(' expr ')' { $$ = ast_cap($2); }
;

%%

#pragma GCC diagnostic pop

extern "C" {

void yyerror(const char *pattern, const char *msg)
{
    fprintf(stderr, "%s (on RE %s)", msg, pattern);
    exit(1);
}

int yylex(const char *&pattern)
{
    return lex(pattern);
}

} // extern "C"

namespace re2c {

const AST *parse(const char *pattern)
{
    yyparse(pattern);
    return regexp;
}

} // namespace re2c
