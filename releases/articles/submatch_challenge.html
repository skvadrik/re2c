
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Fast submatch extraction &#8212; re2c 4.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/theme-re2c.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="alternate" type="application/atom+xml" href="../../feed/atom.xml" title="Atom 1.0" />
    
 
  </head><body>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="re2c-logo">
    re2c
</div>

<h3><a href="../../index.html">Home</a></h3>
<div class="re2c-toc-global">
    <ul>
<li class="toctree-l1"><a class="reference internal" href="../../manual/manual.html">User manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../build/build.html">Build &amp; install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../benchmarks/benchmarks.html">Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog/changelog.html">Changelog</a></li>
</ul>

</div>
    <h3>Fast submatch extraction</h3>
    <div class="re2c-toc-local">
        <ul>
<li><a class="reference internal" href="#">Fast submatch extraction</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#recognition">Recognition</a></li>
<li><a class="reference internal" href="#the-difficulty-with-dfa">The difficulty with DFA</a></li>
<li><a class="reference internal" href="#dangerous-trailing-contexts">Dangerous trailing contexts</a></li>
</ul>
</li>
</ul>

    </div>

        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="fast-submatch-extraction">
<h1>Fast submatch extraction<a class="headerlink" href="#fast-submatch-extraction" title="Permalink to this heading">¶</a></h1>
<p><em>by Ulya Trofimovich</em></p>
<p>This article is an informal description
of the <a class="reference external" href="../../2017_trofimovich_tagged_deterministic_finite_automata_with_lookahead.pdf">novel algorithm</a>
used in <a class="reference external" href="../release_notes/1_0.html">re2c-1.0</a>
to implement <a class="reference external" href="../../manual/features/submatch/submatch.html">submatch extraction</a>.
It tries to explain what is it so complex about this seemingly simple problem,
why re2c has such a strange interface,
and how <em>tags</em> are related to the familiar <em>capturing groups</em> used by other regular expression engines.</p>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">¶</a></h2>
<p><em>Regular expressions</em> is a syntactic notation for describing <em>sets</em>.
Usually it is assumed that these sets contain strings — sequences of characters over some fixed alphabet.
This is known as the <em>language interpretation</em> of regular expressions.
For example, <span class="math notranslate nohighlight">\(a^*b^*\)</span> denotes language <span class="math notranslate nohighlight">\(L\)</span> that contains all strings
composed by a sequence of <span class="math notranslate nohighlight">\(a\)</span> followed by a sequence of <span class="math notranslate nohighlight">\(b\)</span>.
Special symbol <span class="math notranslate nohighlight">\(\epsilon\)</span> means “empty string”:</p>
<div class="math notranslate nohighlight">
\[L(a^*b^*) = \{\epsilon, a, b, aa, ab, bb, ...\}\]</div>
<p>Regular expressions is one possible way of describing <em>regular languages</em> —
the class of languages generated by Type 3 grammars in the Chomsky hierarchy.
For every regular expression there is an equivalent Type 3 grammar that generates the same language and vice versa.
For example, the above language <span class="math notranslate nohighlight">\(L\)</span> can be generated by the grammar <span class="math notranslate nohighlight">\(G = (V_T, V_N, R, S)\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\text{alphabet of terminals:} &amp;\quad     V_T = \{ a, b \} \\
\text{alphabet of non-terminals:} &amp;\quad V_N = \{ A, B \} \\
\text{production rules:} &amp;\quad          R = \{
A \rightarrow aA | bB | a | b | \epsilon,
B \rightarrow bB | b
\} \\
\text{start symbol:} &amp;\quad S = A\end{split}\]</div>
<p>It is often said that regular expressions are used for <em>matching</em> strings.
But what exactly is matching?
In the narrow sense of the word it means <em>recognition</em>:
deciding if the given string belongs to the language denoted by the regular expression.
For example, <span class="math notranslate nohighlight">\(aaabb \in L\)</span>, but <span class="math notranslate nohighlight">\(aba \not\in L\)</span>.
In the broad sense of the word matching means <em>parsing</em>:
besides solving the membership problem
it is also necessary to find the <em>derivation</em> — the sequence of grammar rules that transform start symbol into the input string.
Derivation gives more information than a simple membership test
because it reconstructs the <em>structure</em> of the input string.
For example, <span class="math notranslate nohighlight">\(aaabb\)</span> is derived as follows in the grammar <span class="math notranslate nohighlight">\(G\)</span>:</p>
<div class="math notranslate nohighlight">
\[A
\rightarrow aA
\rightarrow aaA
\rightarrow aaaA
\rightarrow aaabB
\rightarrow aaabb\]</div>
<p>There is no exact analogue of “derivation” in terms of regular expressions,
as their primary application is recognition, not parsing.
Yet sometimes it is convenient to know which part of the input string
corresponds to a particular part of the regular expression —
the problem known as <em>submatch extraction</em>.
In our example one might want to know the substrings corresponding to <span class="math notranslate nohighlight">\(a^*\)</span> and <span class="math notranslate nohighlight">\(b^*\)</span>;
this is usually denoted with the help of <em>capturing parentheses</em>: <span class="math notranslate nohighlight">\((a^*)(b^*)\)</span>.
Submatch extraction is similar to parsing:
in order to find submatch boundaries we need to know a bit of the input structure.
However, unlike parsing, there is no need to reconstruct the full structure down to each character.</p>
<div class="math notranslate nohighlight">
\[\underbrace{aaa}_{a^*} \underbrace{bb}_{b^*}\]</div>
<p>Recognition problem can be solved by converting the regular expression to a <em>nondeterministic finite automaton</em> (NFA)
or an equivalent <em>deterministic finite automaton</em> (DFA).
Parsing and submatch extraction are inherently more complex than recognition,
and they require a more complex type of automata: <em>nondeterministic finite state transducers</em> (NFST).
Unlike NFA, NFST are strictly more powerful than their deterministic analogues (DFST):
it is possible to perform determinization, but the resulting automaton is of a more sophisticated type than DFST.</p>
</section>
<section id="recognition">
<h2>Recognition<a class="headerlink" href="#recognition" title="Permalink to this heading">¶</a></h2>
<img alt="../../_images/nfa_simple.png" src="../../_images/nfa_simple.png" />
<p>aaaa</p>
<img alt="../../_images/nfa.png" src="../../_images/nfa.png" />
<p>aaaa</p>
<img alt="../../_images/dfa_raw.png" src="../../_images/dfa_raw.png" />
<p>aaaaa</p>
<img alt="../../_images/dfa.png" src="../../_images/dfa.png" />
<p>aaaa</p>
<img alt="../../_images/dfa_min.png" src="../../_images/dfa_min.png" />
<p>Recognition problem can be solved by converting the regular expression to a <em>nondeterministic finite automaton</em> (NFA)
and simulating NFA moves on the input string.
Simulation takes linear time, but since the automaton is nondeterministic,
it is necessary to track many possible paths simultaneously.
Alternatively, one can convert NFA to an equivalent <em>deterministic finite automaton</em> (DFA),
which also runs in linear time, but is much faster then NFA — there is only one possible path to track.
The <em>determinization</em> procedure is quite complex;
in the worst case it may take exponential time and generate a very large DFA.
Therefore determinization is only worthwile
if it can be performed ahead of time (in lexer generators like re2c),
or if the same regular expression is used multiple times.
Some engines try to get the best of both worlds by using <em>lazy determinization</em>:
NFA simulation with memoization of all intermediate states.</p>
<p>In terms of NFA “derivation” means “path”,
and parsing means finding this path — a chain of transitions from initial state to final state which spells the input string.
This cannot be done by the means of traditional NFA,
as the only output they produce is a yes/no answer:
simulation either ends in a final state or not.
In order to remember the path automaton must be able to record its moves.
Such automata are known as <em>nondeterministic finite state transducers</em> (NFST):
they are like ordinary NFA extended with an output tape
and transitions that not only read symbols from the input string, but also write symbols on the output tape.
Unlike NFA, NFST cannot be always converted to DFST: nondeterminisitc transducers are strictly more powerful.
However, it is possible to turn NFST into a more complex type of determinisitc automata.
Devising and constructing such automata is the main challenge of parsing and submatch extraction.</p>
</section>
<section id="the-difficulty-with-dfa">
<h2>The difficulty with DFA<a class="headerlink" href="#the-difficulty-with-dfa" title="Permalink to this heading">¶</a></h2>
</section>
<section id="dangerous-trailing-contexts">
<h2>Dangerous trailing contexts<a class="headerlink" href="#dangerous-trailing-contexts" title="Permalink to this heading">¶</a></h2>
<p>The challenge of implementing submatch extraction in lexer generators like re2c is not immediately obvious.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
      Last updated on Jan 01, 1980.
    </div>
  </body>
</html>