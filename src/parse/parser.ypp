%{

// disable certain GCC and/or Clang warnings,  as we have no control over
// autogenerated code (Clang also understands '#pragma GCC')
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpragmas"
#pragma GCC diagnostic ignored "-Wconversion"
#pragma GCC diagnostic ignored "-Wsign-conversion"
#pragma GCC diagnostic ignored "-Wunused-macros"
#pragma GCC diagnostic ignored "-Wmissing-variable-declarations"
#pragma GCC diagnostic ignored "-Wunreachable-code"
#pragma GCC diagnostic ignored "-Wunreachable-code-break"

#include "src/parse/parse.h"
#include "src/msg/msg.h"
#include "src/options/opt.h"


using namespace re2c;

extern "C" {

int yylex(context_t &context);
void yyerror(context_t &context, const char*) RE2C_ATTR((noreturn));

} // extern "C"

%}

%start spec

%lex-param   {re2c::context_t &context}
%parse-param {re2c::context_t &context}

%union {
    const re2c::AST *regexp;
    re2c::SemAct    *semact;
    char             op;
    re2c::ASTBounds  bounds;
    std::string     *str;
    re2c::CondList  *clist;
};

%token TOKEN_CJUMP
%token TOKEN_CNEXT
%token TOKEN_CLIST
%token TOKEN_CSETUP
%token TOKEN_CZERO
%token TOKEN_CLOSESIZE
%token TOKEN_CODE
%token TOKEN_CONF
%token TOKEN_ID
%token TOKEN_FID
%token TOKEN_FID_END
%token TOKEN_LINE_INFO
%token TOKEN_REGEXP
%token TOKEN_BLOCK

%type <op>      close closes
%type <bounds>  TOKEN_CLOSESIZE
%type <semact>  TOKEN_CODE ccode
%type <regexp>  TOKEN_REGEXP trailexpr rule expr diff term factor primary
%type <str>     TOKEN_CNEXT TOKEN_CJUMP TOKEN_ID TOKEN_FID TOKEN_BLOCK name
%type <clist>   TOKEN_CLIST TOKEN_CSETUP TOKEN_CZERO

%%

spec
: /* empty */
| spec TOKEN_BLOCK {
    use_block(context, *$2, context.input.tok_loc(), context.input.msg);
    delete $2;
}
| spec TOKEN_CONF {
    context.input.lex_conf(context.opts);
}
| spec def
| spec rule
| spec TOKEN_LINE_INFO
;

def
: name expr enddef {
    add_named_def(context.opts.symtab, *$1, $2, context.input.tok_loc(),
        context.input.msg);
    delete $1;
}
/* errors */
| name expr '/' {
    context.input.msg.error(context.input.tok_loc()
        , "trailing contexts are not allowed in named definitions");
    exit(1);
};

name
: TOKEN_ID '=' { $$ = $1; }
| TOKEN_FID
;

enddef: ';' | TOKEN_FID_END;

rule
: trailexpr TOKEN_CODE {
    find_or_add_spec(context.specs, "").rules.push_back(ASTRule($1, $2));
}
| '*' TOKEN_CODE {
    find_or_add_spec(context.specs, "").defs.push_back($2);
}
| '$' TOKEN_CODE {
    find_or_add_spec(context.specs, "").eofs.push_back($2);
}
| TOKEN_CLIST trailexpr ccode {
    for(CondList::const_iterator i = $1->begin(); i != $1->end(); ++i) {
        find_or_add_spec(context.specs, *i).rules.push_back(ASTRule($2, $3));
    }
    delete $1;
}
| TOKEN_CLIST '*' ccode {
    for(CondList::const_iterator i = $1->begin(); i != $1->end(); ++i) {
        find_or_add_spec(context.specs, *i).defs.push_back($3);
    }
    delete $1;
}
| TOKEN_CLIST '$' ccode {
    for(CondList::const_iterator i = $1->begin(); i != $1->end(); ++i) {
        find_or_add_spec(context.specs, *i).eofs.push_back($3);
    }
    delete $1;
}
| TOKEN_CSETUP TOKEN_CODE {
    for (CondList::const_iterator i = $1->begin(); i != $1->end(); ++i) {
        find_or_add_spec(context.specs, *i).setup.push_back($2);
    }
    delete $1;
}
| TOKEN_CZERO ccode {
    const AST *r = ast_nil(context.input.tok_loc());
    find_or_add_spec(context.specs, "0").rules.push_back(ASTRule(r, $2));
    delete $1;
};

ccode
: TOKEN_CODE
| TOKEN_CNEXT TOKEN_CODE {
    $$ = $2;
    $$->cond = *$1;
    delete $1;
}
| TOKEN_CJUMP {
    $$ = new SemAct(context.input.tok_loc());
    $$->cond = *$1;
    delete $1;
};

trailexpr
: expr { $$ = ast_cap($1); }
| expr '/' expr {
    $$ = ast_cat(ast_cap($1),
        ast_cat(ast_tag(context.input.tok_loc(), NULL, false), $3));
};

expr
: diff
| expr '|' diff { $$ = ast_alt($1, $3); }
;

diff
: term
| diff '\\' term { $$ = ast_diff($1, $3); }
;

term
: factor
// in POSIX concatenation is right-associative
| factor term { $$ = ast_cat($1, $2); }
;

factor
: primary
| primary closes {
    switch($2) {
        case '*': $$ = ast_iter($1, 0, AST::MANY); break;
        case '+': $$ = ast_iter($1, 1, AST::MANY); break;
        case '?': $$ = ast_iter($1, 0, 1); break;
    }
}
| primary TOKEN_CLOSESIZE {
    $$ = ast_iter($1, $2.min, $2.max);
}
;

closes
: close
| closes close { $$ = ($1 == $2) ? $1 : '*'; }
;

close
: '*' { $$ = '*'; }
| '+' { $$ = '+'; }
| '?' { $$ = '?'; }
;

primary
: TOKEN_REGEXP
| TOKEN_ID {
    $$ = find_def(context.opts.symtab, *$1, context.input.tok_loc(), context.input.msg);
    if (ast_need_wrap($$)) {
        $$ = ast_ref($$, *$1);
    }
    delete $1;
}
| '(' expr ')' { $$ = ast_cap($2); }
;

%%

#pragma GCC diagnostic pop

extern "C" {

void yyerror(context_t &context, const char* s)
{
    context.input.msg.error(context.input.tok_loc(), "%s", s);
    exit(1);
}

int yylex(context_t &context)
{
    return context.input.scan();
}

} // extern "C"

namespace re2c {

void parse(Scanner &input, specs_t &specs, Opt &opts, const RulesBlocks &rblocks)
{
    context_t context = {input, specs, opts, rblocks};
    yyparse(context);
}

} // namespace re2c
