%code requires {

#include "src/util/containers.h"

namespace re2c {
struct StxConf;
struct StxCode;
struct StxExpr;
struct StxName;
using StxCodes = list_t<StxCode>;
using StxList = list_t<StxName>;
class Stx;
class StxFile;
} // namespace re2c

}

%{
#include <stdint.h>

#include "src/codegen/syntax.h"
#include "src/codegen/syntax_parser.h"
#include "src/msg/msg.h"

using namespace re2c;

extern "C" {
    static void yyerror(StxFile& sf, re2c::Stx&, const char* s);
    static int yylex(YYSTYPE* yylval, StxFile& sf);
}

%}

%start confs

%define api.pure full
%lex-param {re2c::StxFile& sf}
%parse-param {re2c::StxFile& sf}
%parse-param {re2c::Stx& stx}

%union {
    const char* str;
    int32_t num;
    re2c::StxConf* conf;
    re2c::StxExpr* expr;
    re2c::StxList* list;
    re2c::StxCode* code;
    re2c::StxCodes* codes;
};

%token STX_NAME
%token STX_NUMBER
%token STX_STRING
%token STX_CONF
%token STX_CONF_CODE

%type <str> STX_NAME STX_STRING STX_CONF STX_CONF_CODE
%type <num> STX_NUMBER
%type <conf> conf
%type <expr> expr
%type <list> list names
%type <code> code_cond code_expr code_list
%type <codes> code_exprs

%%

confs
: %empty
| conf confs { stx.add_conf($1->name, $1); };

conf
: STX_CONF_CODE code_exprs ';' {
    $$ = stx.make_conf_code($1, $2);
    if (stx.validate_conf_code($$) == Ret::FAIL) YYABORT;
}
| STX_CONF list ';' {
    $$ = stx.make_conf_list($1, $2);
    if (stx.validate_conf_list($$) == Ret::FAIL) YYABORT;
}
| STX_CONF expr ';' {
    $$ = stx.make_conf_expr($1, $2);
    if (stx.validate_conf_expr($$) == Ret::FAIL) YYABORT;
};

// code expressions (for configurations that start with `code:`)

code_exprs
: %empty               { $$ = stx.new_code_list(); }
| code_expr code_exprs { prepend($2, $1); $$ = $2; };

code_expr
: STX_STRING { $$ = stx.make_code_str($1); }
| STX_NAME   { $$ = stx.make_code_var($1); }
| code_cond
| code_list;

code_cond
: '(' STX_NAME '?' code_exprs ')' {
    $$ = stx.make_code_cond($2, $4, nullptr);
}
| '(' STX_NAME '?' code_exprs ':' code_exprs ')' {
    $$ = stx.make_code_cond($2, $4, $6);
};

code_list
: '[' STX_NAME ':' code_exprs ']' {
    $$ = stx.make_code_list($2, 0, -1, $4);
}
| '[' STX_NAME '{' STX_NUMBER '}' ':' code_exprs ']' {
    $$ = stx.make_code_list($2, $4, $4, $7);
}
| '[' STX_NAME '{' STX_NUMBER ':' STX_NUMBER '}' ':' code_exprs ']' {
    $$ = stx.make_code_list($2, $4, $6, $9);
};

// generic expressions (lists, conditional expressions, single words)

list: '[' names ']' { $$ = $2; };

names
: STX_NAME {
    $$ = stx.new_name_list();
    prepend($$, stx.make_name($1));
}
| STX_NAME ',' names {
    prepend($3, stx.make_name($1));
    $$ = $3;
};

expr
: STX_NAME                           { $$ = stx.make_expr_name($1); }
| '(' STX_NAME '?' expr ':' expr ')' { $$ = stx.make_expr_cond($2, $4, $6); };

%%

extern "C" {
    static void yyerror(re2c::StxFile& sf, re2c::Stx&, const char* s) {
        sf.msg.error(sf.tok_loc(), "%s", s);
    }

    static int yylex(YYSTYPE* yylval, re2c::StxFile& sf) {
        return sf.lex_token(yylval);
    }
}

namespace re2c {

Ret StxFile::parse(Stx& stx) {
    return yyparse(*this, stx) == 0 ? Ret::OK : Ret::FAIL;
}

} // namespace re2c
