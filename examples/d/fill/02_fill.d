/* Generated by re2c 3.0 on Sun Jan  8 16:26:41 2023 */
#line 1 "02_fill.re"
// re2c $INPUT -o $OUTPUT
module fill_02;

import core.stdc.string;
import core.stdc.stdio;

#line 10 "02_fill.d"
enum YYMAXFILL = 1;
#line 7 "02_fill.re"

enum BUFSIZE = (4096 - YYMAXFILL);

struct Input {
    FILE *file;
    char[BUFSIZE + YYMAXFILL] buf;
    char* lim, cur, tok;
    bool eof;
};

int fill(ref Input input, size_t need) {
    if (input.eof) return 1;

    const size_t shift = input.tok - input.buf.ptr;
    const size_t used = input.lim - input.tok;

    // Error: lexeme too long. In real life could reallocate a larger buffer.
    if (shift < need) return 2;

    // Shift buffer contents (discard everything up to the current token).
    memmove(input.buf.ptr, input.tok, used);
    input.lim -= shift;
    input.cur -= shift;
    input.tok -= shift;

    // Fill free space at the end of buffer with new data from file.
    input.lim += fread(input.lim, 1, BUFSIZE - used, input.file);

    // If read less than expected, this is end of input => add zero padding
    // so that the lexer can access characters at the end of buffer.
    if (input.lim < input.buf.ptr + BUFSIZE) {
        input.eof = true;
        memset(input.lim, 0, YYMAXFILL);
        input.lim += YYMAXFILL;
    }

    return 0;
}

int lex(ref Input input) {
    int count = 0;
    for (;;) {
        input.tok = input.cur;
    
#line 57 "02_fill.d"
{
	char yych;
	if (input.lim <= input.cur) if (fill(input, 1) != 0) return -1;
	yych = (*input.cur);
	if (yych <= ' ') {
		if (yych <= 0x0000) goto yy1;
		if (yych <= 0x001F) goto yy2;
		goto yy3;
	} else {
		if (yych == '\'') goto yy4;
		goto yy2;
	}
yy1:
	input.cur++;
#line 65 "02_fill.re"
	{
            // Check that it is the sentinel, not some unexpected null.
            return input.tok == input.lim - YYMAXFILL ? count : -1;
        }
#line 77 "02_fill.d"
yy2:
	input.cur++;
#line 71 "02_fill.re"
	{ return -1; }
#line 82 "02_fill.d"
yy3:
	input.cur++;
	if (input.lim <= input.cur) if (fill(input, 1) != 0) return -1;
	yych = (*input.cur);
	if (yych == ' ') goto yy3;
#line 70 "02_fill.re"
	{ continue; }
#line 90 "02_fill.d"
yy4:
	input.cur++;
	if (input.lim <= input.cur) if (fill(input, 1) != 0) return -1;
	yych = (*input.cur);
	if (yych == '\'') goto yy5;
	if (yych == '\\') goto yy6;
	goto yy4;
yy5:
	input.cur++;
#line 69 "02_fill.re"
	{ ++count; continue; }
#line 102 "02_fill.d"
yy6:
	input.cur++;
	if (input.lim <= input.cur) if (fill(input, 1) != 0) return -1;
	goto yy4;
}
#line 72 "02_fill.re"

    }
    assert(0);
}

unittest{
    const char[] fname = "input";
    const char[] content = "'qu\0tes' 'are' 'fine: \\'' ";

    // Prepare input file: a few times the size of the buffer, containing
    // strings with zeroes and escaped quotes.
    FILE *f = fopen(fname.ptr, "w");
    for (int i = 0; i < BUFSIZE; ++i) {
        fwrite(content.ptr, 1, content.length - 1, f);
    }
    fclose(f);
    int count = 3 * BUFSIZE; // number of quoted strings written to file

    // Initialize lexer state: all pointers are at the end of buffer.
    // This immediately triggers YYFILL, as the check `in.cur < in.lim` fails.
    Input input;
    input.file = fopen(fname.ptr, "r");
    input.cur = input.tok = input.lim = input.buf.ptr + BUFSIZE;
    input.eof = 0;

    // Run the lexer.
    assert(lex(input) == count);

    // Cleanup: remove input file.
    fclose(input.file);
    remove(fname.ptr);
}

extern(C) void main()
{
    static foreach(u; __traits(getUnitTests, __traits(parent, main)))
        u();
}

