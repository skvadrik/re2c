/* Generated by re2swift */
#sourceLocation(file: "swift/submatch/04_posix_captures.re", line: 1)
// re2swift $INPUT -o $OUTPUT

// Maximum number of capturing groups among all rules.
#sourceLocation(file: "swift/submatch/04_posix_captures.swift", line: 7)
let yymaxnmatch = 4
#sourceLocation(file: "swift/submatch/04_posix_captures.re", line: 4)


struct SemVer: Equatable { var major: Int, minor: Int, patch: Int }

func lex(_ yyinput: UnsafePointer<UInt8>) -> SemVer? {
  let tagNone = -1

  var yycursor = 0, yymarker = 0

  // Allocate memory for capturing parentheses (twice the number of groups).
  var yypmatch = [Int](repeating: 0, count: yymaxnmatch * 2)
  let yynmatch: Int

  // Intermediate tag variables used by the lexer (must be autogenerated).
  
#sourceLocation(file: "swift/submatch/04_posix_captures.swift", line: 25)
  var yyt1: Int = tagNone
  var yyt2: Int = tagNone
  var yyt3: Int = tagNone
  var yyt4: Int = tagNone
  var yyt5: Int = tagNone
#sourceLocation(file: "swift/submatch/04_posix_captures.re", line: 18)


  
#sourceLocation(file: "swift/submatch/04_posix_captures.swift", line: 35)
  var yych: UInt8 = 0
  var yystate: UInt = 0
  yyl: while true {
    switch yystate {
      case 0:
        yych = yyinput[yycursor]
        switch yych {
          case 0x30...0x39:
            yyt1 = yycursor
            yycursor += 1
            yystate = 3
            continue yyl
          default:
            yycursor += 1
            yystate = 1
            continue yyl
        }
      case 1:
        yystate = 2
        continue yyl
      case 2:
#sourceLocation(file: "swift/submatch/04_posix_captures.re", line: 36)
        return nil
#sourceLocation(file: "swift/submatch/04_posix_captures.swift", line: 59)
      case 3:
        yymarker = yycursor
        yych = yyinput[yycursor]
        switch yych {
          case 0x2E:
            yycursor += 1
            yystate = 4
            continue yyl
          case 0x30...0x39:
            yycursor += 1
            yystate = 6
            continue yyl
          default:
            yystate = 2
            continue yyl
        }
      case 4:
        yych = yyinput[yycursor]
        switch yych {
          case 0x30...0x39:
            yyt2 = yycursor
            yycursor += 1
            yystate = 7
            continue yyl
          default:
            yystate = 5
            continue yyl
        }
      case 5:
        yycursor = yymarker
        yystate = 2
        continue yyl
      case 6:
        yych = yyinput[yycursor]
        switch yych {
          case 0x2E:
            yycursor += 1
            yystate = 4
            continue yyl
          case 0x30...0x39:
            yycursor += 1
            yystate = 6
            continue yyl
          default:
            yystate = 5
            continue yyl
        }
      case 7:
        yych = yyinput[yycursor]
        switch yych {
          case 0x00:
            yyt3 = yycursor
            yyt4 = -1
            yyt5 = -1
            yycursor += 1
            yystate = 8
            continue yyl
          case 0x2E:
            yyt3 = yycursor
            yyt5 = yycursor
            yycursor += 1
            yystate = 9
            continue yyl
          case 0x30...0x39:
            yycursor += 1
            yystate = 7
            continue yyl
          default:
            yystate = 5
            continue yyl
        }
      case 8:
        yynmatch = 4
        yypmatch[2] = yyt1
        yypmatch[4] = yyt2
        yypmatch[5] = yyt3
        yypmatch[6] = yyt5
        yypmatch[7] = yyt4
        yypmatch[0] = yyt1
        yypmatch[1] = yycursor
        yypmatch[3] = yyt2
                yypmatch[3] -= 1
#sourceLocation(file: "swift/submatch/04_posix_captures.re", line: 26)
        
      // `yynmatch` is the number of capturing groups.
      assert(yynmatch == 4)
      // Even `yypmatch` values are for opening parentheses, odd values
      // are for closing parentheses, the first group is the whole match.
      return SemVer(
        major: s2n(yypmatch[2]..<yypmatch[3]),
        minor: s2n(yypmatch[4]..<yypmatch[5]),
        patch: yypmatch[6] != tagNone ? s2n((yypmatch[6] + 1)..<yypmatch[7]) : 0)

#sourceLocation(file: "swift/submatch/04_posix_captures.swift", line: 153)
      case 9:
        yych = yyinput[yycursor]
        if yych <= 0x00 {
          yystate = 5
          continue yyl
        }
        yystate = 11
        continue yyl
      case 10:
        yych = yyinput[yycursor]
        yystate = 11
        continue yyl
      case 11:
        switch yych {
          case 0x00:
            yyt4 = yycursor
            yycursor += 1
            yystate = 8
            continue yyl
          case 0x30...0x39:
            yycursor += 1
            yystate = 10
            continue yyl
          default:
            yystate = 5
            continue yyl
        }
      default: fatalError("internal lexer error")
    }
  }
#sourceLocation(file: "swift/submatch/04_posix_captures.re", line: 37)


  func s2n(_ range: Range<Int>) -> Int {
    range.reduce(0) { accum, idx in
      accum * 10 + Int(yyinput[idx] - UInt8(ascii: "0"))
    }
  }
}

assert(lex("23.34") == SemVer(major: 23, minor: 34, patch: 0))
assert(lex("1.2.999") == SemVer(major: 1, minor: 2, patch: 999))
assert(lex("1.a") == nil)
