/* Generated by re2swift */
#sourceLocation(file: "swift/conditions/parse_u32_blocks.re", line: 1)
// re2swift $INPUT -o $OUTPUT

func parseUInt32(_ yyinput: UnsafePointer<UInt8>) -> UInt32? {
  var yycursor = 0, yymarker = 0

  
#sourceLocation(file: "swift/conditions/parse_u32_blocks.swift", line: 10)
  var yych: UInt8 = 0
  var yystate: UInt = 0
  yyl: while true {
    switch yystate {
      case 0:
        yych = yyinput[yycursor]
        yycursor += 1
        switch yych {
          case 0x30:
            yystate = 2
            continue yyl
          case 0x31...0x39:
            yystate = 4
            continue yyl
          default:
            yystate = 1
            continue yyl
        }
      case 1:
#sourceLocation(file: "swift/conditions/parse_u32_blocks.re", line: 13)
        return nil
#sourceLocation(file: "swift/conditions/parse_u32_blocks.swift", line: 32)
      case 2:
        yymarker = yycursor
        yych = yyinput[yycursor]
        switch yych {
          case 0x62:
            yycursor += 1
            yystate = 5
            continue yyl
          case 0x78:
            yycursor += 1
            yystate = 7
            continue yyl
          default:
            yystate = 3
            continue yyl
        }
      case 3:
#sourceLocation(file: "swift/conditions/parse_u32_blocks.re", line: 10)
        return parseOct()
#sourceLocation(file: "swift/conditions/parse_u32_blocks.swift", line: 52)
      case 4:
        yycursor -= 1
#sourceLocation(file: "swift/conditions/parse_u32_blocks.re", line: 11)
        return parseDec()
#sourceLocation(file: "swift/conditions/parse_u32_blocks.swift", line: 57)
      case 5:
        yych = yyinput[yycursor]
        switch yych {
          case 0x30...0x31:
            yycursor += 1
            yystate = 8
            continue yyl
          default:
            yystate = 6
            continue yyl
        }
      case 6:
        yycursor = yymarker
        yystate = 3
        continue yyl
      case 7:
        yych = yyinput[yycursor]
        switch yych {
          case 0x30...0x39:
            fallthrough
          case 0x41...0x46:
            fallthrough
          case 0x61...0x66:
            yycursor += 1
            yystate = 9
            continue yyl
          default:
            yystate = 6
            continue yyl
        }
      case 8:
        yycursor -= 1
#sourceLocation(file: "swift/conditions/parse_u32_blocks.re", line: 9)
        return parseBin()
#sourceLocation(file: "swift/conditions/parse_u32_blocks.swift", line: 92)
      case 9:
        yycursor -= 1
#sourceLocation(file: "swift/conditions/parse_u32_blocks.re", line: 12)
        return parseHex()
#sourceLocation(file: "swift/conditions/parse_u32_blocks.swift", line: 97)
      default: fatalError("internal lexer error")
    }
  }
#sourceLocation(file: "swift/conditions/parse_u32_blocks.re", line: 14)


  func add(_ accum: inout UInt64, _ charOrigin: UnicodeScalar, _ base: UInt64, _ offset: UInt64 = 0) {
    let digit = yyinput[yycursor - 1] - UInt8(ascii: charOrigin)
    accum = min(accum * base + UInt64(digit) + offset, UInt64(UInt32.max) + 1)
  }

  func parseBin() -> UInt32? {
    var accum: UInt64 = 0
    parse: while true {
      
#sourceLocation(file: "swift/conditions/parse_u32_blocks.swift", line: 113)
  var yych: UInt8 = 0
  var yystate: UInt = 0
  yyl: while true {
    switch yystate {
      case 0:
        yych = yyinput[yycursor]
        yycursor += 1
        switch yych {
          case 0x30...0x31:
            yystate = 2
            continue yyl
          default:
            yystate = 1
            continue yyl
        }
      case 1:
#sourceLocation(file: "swift/conditions/parse_u32_blocks.re", line: 26)
        return UInt32(exactly: accum)
#sourceLocation(file: "swift/conditions/parse_u32_blocks.swift", line: 132)
      case 2:
#sourceLocation(file: "swift/conditions/parse_u32_blocks.re", line: 25)
        add(&accum, "0", 2); continue parse
#sourceLocation(file: "swift/conditions/parse_u32_blocks.swift", line: 136)
      default: fatalError("internal lexer error")
    }
  }
#sourceLocation(file: "swift/conditions/parse_u32_blocks.re", line: 27)

    }
  }
  func parseOct() -> UInt32? {
    var accum: UInt64 = 0
    parse: while true {
      
#sourceLocation(file: "swift/conditions/parse_u32_blocks.swift", line: 148)
  var yych: UInt8 = 0
  var yystate: UInt = 0
  yyl: while true {
    switch yystate {
      case 0:
        yych = yyinput[yycursor]
        yycursor += 1
        switch yych {
          case 0x30...0x37:
            yystate = 2
            continue yyl
          default:
            yystate = 1
            continue yyl
        }
      case 1:
#sourceLocation(file: "swift/conditions/parse_u32_blocks.re", line: 35)
        return UInt32(exactly: accum)
#sourceLocation(file: "swift/conditions/parse_u32_blocks.swift", line: 167)
      case 2:
#sourceLocation(file: "swift/conditions/parse_u32_blocks.re", line: 34)
        add(&accum, "0", 8); continue parse
#sourceLocation(file: "swift/conditions/parse_u32_blocks.swift", line: 171)
      default: fatalError("internal lexer error")
    }
  }
#sourceLocation(file: "swift/conditions/parse_u32_blocks.re", line: 36)

    }
  }
  func parseDec() -> UInt32? {
    var accum: UInt64 = 0
    parse: while true {
      
#sourceLocation(file: "swift/conditions/parse_u32_blocks.swift", line: 183)
  var yych: UInt8 = 0
  var yystate: UInt = 0
  yyl: while true {
    switch yystate {
      case 0:
        yych = yyinput[yycursor]
        yycursor += 1
        switch yych {
          case 0x30...0x39:
            yystate = 2
            continue yyl
          default:
            yystate = 1
            continue yyl
        }
      case 1:
#sourceLocation(file: "swift/conditions/parse_u32_blocks.re", line: 44)
        return UInt32(exactly: accum)
#sourceLocation(file: "swift/conditions/parse_u32_blocks.swift", line: 202)
      case 2:
#sourceLocation(file: "swift/conditions/parse_u32_blocks.re", line: 43)
        add(&accum, "0", 10); continue parse
#sourceLocation(file: "swift/conditions/parse_u32_blocks.swift", line: 206)
      default: fatalError("internal lexer error")
    }
  }
#sourceLocation(file: "swift/conditions/parse_u32_blocks.re", line: 45)

    }
  }
  func parseHex() -> UInt32? {
    var accum: UInt64 = 0
    parse: while true {
      
#sourceLocation(file: "swift/conditions/parse_u32_blocks.swift", line: 218)
  var yych: UInt8 = 0
  var yystate: UInt = 0
  yyl: while true {
    switch yystate {
      case 0:
        yych = yyinput[yycursor]
        yycursor += 1
        switch yych {
          case 0x30...0x39:
            yystate = 2
            continue yyl
          case 0x41...0x46:
            yystate = 3
            continue yyl
          case 0x61...0x66:
            yystate = 4
            continue yyl
          default:
            yystate = 1
            continue yyl
        }
      case 1:
#sourceLocation(file: "swift/conditions/parse_u32_blocks.re", line: 55)
        return UInt32(exactly: accum)
#sourceLocation(file: "swift/conditions/parse_u32_blocks.swift", line: 243)
      case 2:
#sourceLocation(file: "swift/conditions/parse_u32_blocks.re", line: 52)
        add(&accum, "0", 16);     continue parse
#sourceLocation(file: "swift/conditions/parse_u32_blocks.swift", line: 247)
      case 3:
#sourceLocation(file: "swift/conditions/parse_u32_blocks.re", line: 54)
        add(&accum, "A", 16, 10); continue parse
#sourceLocation(file: "swift/conditions/parse_u32_blocks.swift", line: 251)
      case 4:
#sourceLocation(file: "swift/conditions/parse_u32_blocks.re", line: 53)
        add(&accum, "a", 16, 10); continue parse
#sourceLocation(file: "swift/conditions/parse_u32_blocks.swift", line: 255)
      default: fatalError("internal lexer error")
    }
  }
#sourceLocation(file: "swift/conditions/parse_u32_blocks.re", line: 56)

    }
  }
}

assert(parseUInt32("") == nil)
assert(parseUInt32("1234567890") == 1234567890)
assert(parseUInt32("0b1101") == 13)
assert(parseUInt32("0x7Fe") == 2046)
assert(parseUInt32("0644") == 420)
assert(parseUInt32("9999999999") == nil)
