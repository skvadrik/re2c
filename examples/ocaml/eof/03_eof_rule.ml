(* Generated by re2c *)
#1 "ocaml/eof/03_eof_rule.re"
(* re2ocaml $INPUT -o $OUTPUT *)

open String

type state = {
    str: string;
    mutable cur: int;
    mutable mar: int;
    lim: int;
}

(* expect a null-terminated string *)

#17 "ocaml/eof/03_eof_rule.ml"
let rec yy0 (yyrecord : state) (count : int) : int =
	let yych = get yyrecord.str yyrecord.cur in
	match yych with
		| ' ' ->
			yyrecord.cur <- yyrecord.cur + 1;
			(yy3 [@tailcall]) yyrecord count
		| '\'' ->
			yyrecord.cur <- yyrecord.cur + 1;
			(yy5 [@tailcall]) yyrecord count
		| _ ->
			if (yyrecord.lim <= yyrecord.cur) then (
				(yy10 [@tailcall]) yyrecord count
			) else (
				yyrecord.cur <- yyrecord.cur + 1;
				(yy1 [@tailcall]) yyrecord count
			)

and yy1 (yyrecord : state) (count : int) : int =
	(yy2 [@tailcall]) yyrecord count

and yy2 (yyrecord : state) (count : int) : int =
#21 "ocaml/eof/03_eof_rule.re"
	-1
#41 "ocaml/eof/03_eof_rule.ml"

and yy3 (yyrecord : state) (count : int) : int =
	let yych = get yyrecord.str yyrecord.cur in
	match yych with
		| ' ' ->
			yyrecord.cur <- yyrecord.cur + 1;
			(yy3 [@tailcall]) yyrecord count
		| _ -> (yy4 [@tailcall]) yyrecord count

and yy4 (yyrecord : state) (count : int) : int =
#24 "ocaml/eof/03_eof_rule.re"
	lex yyrecord count
#54 "ocaml/eof/03_eof_rule.ml"

and yy5 (yyrecord : state) (count : int) : int =
	yyrecord.mar <- yyrecord.cur;
	let yych = get yyrecord.str yyrecord.cur in
	if (yych <= '\x00') then (
		if (yyrecord.lim <= yyrecord.cur) then (
			(yy2 [@tailcall]) yyrecord count
		) else (
			yyrecord.cur <- yyrecord.cur + 1;
			(yy6 [@tailcall]) yyrecord count
		)
	) else (
		(yy7 [@tailcall]) yyrecord count yych
	)

and yy6 (yyrecord : state) (count : int) : int =
	let yych = get yyrecord.str yyrecord.cur in
	(yy7 [@tailcall]) yyrecord count yych

and yy7 (yyrecord : state) (count : int) (yych : char) : int =
	match yych with
		| '\'' ->
			yyrecord.cur <- yyrecord.cur + 1;
			(yy8 [@tailcall]) yyrecord count
		| '\\' ->
			yyrecord.cur <- yyrecord.cur + 1;
			(yy9 [@tailcall]) yyrecord count
		| _ ->
			if (yyrecord.lim <= yyrecord.cur) then (
				(yy11 [@tailcall]) yyrecord count
			) else (
				yyrecord.cur <- yyrecord.cur + 1;
				(yy6 [@tailcall]) yyrecord count
			)

and yy8 (yyrecord : state) (count : int) : int =
#23 "ocaml/eof/03_eof_rule.re"
	lex yyrecord (count + 1)
#93 "ocaml/eof/03_eof_rule.ml"

and yy9 (yyrecord : state) (count : int) : int =
	let yych = get yyrecord.str yyrecord.cur in
	if (yych <= '\x00') then (
		if (yyrecord.lim <= yyrecord.cur) then (
			(yy11 [@tailcall]) yyrecord count
		) else (
			yyrecord.cur <- yyrecord.cur + 1;
			(yy6 [@tailcall]) yyrecord count
		)
	) else (
		yyrecord.cur <- yyrecord.cur + 1;
		(yy6 [@tailcall]) yyrecord count
	)

and yy10 (yyrecord : state) (count : int) : int =
#22 "ocaml/eof/03_eof_rule.re"
	count
#112 "ocaml/eof/03_eof_rule.ml"

and yy11 (yyrecord : state) (count : int) : int =
	yyrecord.cur <- yyrecord.mar;
	(yy2 [@tailcall]) yyrecord count

and lex (yyrecord : state) (count : int) : int =
	(yy0 [@tailcall]) yyrecord count

#25 "ocaml/eof/03_eof_rule.re"


let test(str, count) =
    let st = {
        str = str;
        cur = 0;
        mar = 0;
        lim = String.length str - 1; (* termunating null not included *)
    }
    in if not (lex st 0 = count) then raise (Failure "error")

let main () =
    test("\x00", 0);
    test("'qu\x00tes' 'are' 'fine: \\'' \x00", 3);
    test("'unterminated\\'\x00", -1)

let _ = main ()
